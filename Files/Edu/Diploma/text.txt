% Generated by GrindEQ Word-to-LaTeX 2008 
% ========== UNREGISTERED! ========== Please register! ==========
% LaTeX/AMS-LaTeX

\documentclass{article}

%%% remove comment delimiter ('%') and specify encoding parameter if required,
%%% see TeX documentation for additional info (cp1252-Western,cp1251-Cyrillic)
\usepackage[cp1252]{inputenc}

%%% remove comment delimiter ('%') and select language if required
\usepackage[russian,english]{babel}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[dvips]{graphicx}
%%% remove comment delimiter ('%') and specify parameters if required
%\usepackage[dvips]{graphics}

\begin{document}

%%% remove comment delimiter ('%') and select language if required
%\selectlanguage{spanish} 

\noindent 

\noindent 

\noindent 

\noindent 

\noindent 

\noindent 

\noindent 

\[25\] 


\noindent Содержание

\noindent 1. Введение и постановка задачи 32. Алгоритм Берлекэмпа--Месси 53. Реализация алгоритма Берлекэмпа--Месси 143.1. Архитектура реализации 153.2. Класс линейного регистра сдвига 163.3. Класс алгоритма 173.4. Тестирование 184. Декодер для кодов Рида--Соломона 215. Литература 25Приложение 26\eject 1. Введение и постановка задачи

Первоначальная версия алгоритма Берлекэмпа--Месси была изложена Берлекэмпом в 1968 году [1] в качестве элемента конструкции декодера кодов Боуза--Чоудхудри--Хоквингема над конечным полем. Хотя в этой работе была указана возможность формулировки решаемой задачи с использованием понятия линейного регистра сдвига с обратной связью, алгоритм описывался исключительно в терминах полиномов и был весьма сложен для понимания. Спустя год Месси [2] предложил свою интерпретацию алгоритма, как позволяющего  строить линейный регистр сдвига минимальной длины, генерирующий заданную последовательность. Эта интерпретация оказалась полезной для более широкого распространения алгоритма, получившего название по имени этих двух ученых. В некоторых работах алгоритм излагается также с помощью непрерывных дробей и рациональной аппроксимации.

С момента появления алгоритма вышло немало работ, развивающих и обобщающих его идеи. Ниже предложен краткий обзор его применений, исчерпывающую библиографию можно найти в [3]. 

Рядом авторов решались задачи построения полинома наименьшей степени, аннулирующего сразу несколько отрезков над полем, нахождения рангов (степеней минимальных многочленов) всех подотрезков заданного отрезка, обобщения на случай многомерных последовательностей (с использованием теории базисов идеалов в кольцах полиномов от нескольких переменных). Имеются многочисленные результаты применения алгоритма для последовательностей над различными алгебраическими структурами, кольцами разных видов. Были предложены вероятностные версии алгоритма.

Рассматриваемый алгоритм находит применение при декодировании различных классов кодов: кодов Рида--Соломона, кодов БЧХ, циклических и обобщенных циклических кодов, альтернантных кодов и кодов Гоппы, и, наконец, наиболее общего и актуального на сегодня класса кодов -- алгебро-геометрических кодов (вернее, некоторых их подклассов). Алгоритм Берлекэмпа--Месси используется для решения ганкелевых и теплицевых, разреженных и общих систем линейных уравнений, при поиске рациональных аппроксимаций функций и, в частности, аппроксимации Паде. Известны также его приложения в криптографии, при тестировании псевдослучайных последовательностей и для быстрого вычисления в конечных полях.

В работе поставлены следующие задачи:

\noindent \begin{enumerate}
\item 1) )разобрать и представить полное обоснование принципиального алгоритма Берлекэмпа---Месси по работе [4];

\noindent \item 2) )сконструировать структурную схему алгоритма и получить программную реализацию;

\noindent \item 3) )разобрать конструкцию декодера для кодов Рида---Соломона, основанного на алгоритме Берлекэмпа---Месси, и построить структурную схему.
\end{enumerate}

\noindent \eject 2. Алгоритм Берлекэмпа--Месси

Как было отмечено во введении, задачу, решаемую алгоритмом Берлекэмпа--Месси, можно сформулировать по-разному. Для детального понимания принципов работы алгоритма приходится также иметь в виду несколько формулировок и прибегать к каждой в разные моменты времени. Наиболее естественным представляется отталкиваться от задачи нахождения закона рекурсии для линейной рекуррентной последовательности. Введем ряд определений.

\textbf{Определение 1.} \textit{Последовательностью} над полем $K$ будем называть любую функцию $u:{\rm N} _{0} \to K$, заданную на множестве целых неотрицательных чисел и принимающую значения в этом поле. 

Элементы последовательности $u$ будут обозначаться $u(i)$. Будет встречаться также понятие \textit{отрезка последовательности}, которое получается естественным образом из ограничения функции, упомянутой в определении. 

\textbf{Определение 2. }Последовательность $u$ будем называть \textit{линейной рекуррентной последовательностью }(ЛРП) \textit{порядка $m>0$ над полем }$K$, если существуют константы $f_{0} ,\; ...\; ,f_{m-1} \in K$ такие, что

\[u(i+m)=\sum _{j=0}^{m-1}f_{j} \cdot u(i+j) , i\ge 0.\] 
Указанное выражение назовем \textit{законом рекурсии }или \textit{линейным рекуррентным соотношением}.

Как видно, первые $m$ элементов последовательности не связаны какими-либо ограничениями -- они имеют особое значение, их, как правило, называют \textit{начальным отрезком} последовательности $u$.

\textbf{Пример 1.} Пусть $K=F_{2} $, $u=(0,1,1,1,0,0,1,0,1,1)$. Легко убедиться, что $u$ можно представить как отрезок ЛРП с $f=(1,0,1,1)$. Однако, в качестве множителей $f_{i} $ могут быть взяты $f=(1,1,0)$. Зафиксируем возможность появления такой ситуации, введя сначала понятие характеристического полинома ЛРП.

\textbf{Определение 3. }Пусть\textbf{ }$u$ --  ЛРП. Многочлен:

\[F(x)=x^{m} -\sum _{j=0}^{m-1}f_{j} \cdot x^{j}  \] 
с коэффициентами из поля $K$ (этот факт в дальнейшем оговариваться не будет) назовем \textit{характеристическим многочленом }ЛРП $u$.

Таким образом, каждой ЛРП можно поставить в соответствие характеристический многочлен и обратно, каждому нормированному многочлену можно поставить в соответствие ЛРП. Как стало ясно из примера, одна и та же последовательность может задаваться разными законами рекурсии и, соответственно, иметь разные характеристические полиномы.

\textbf{Определение 4. }Характеристический полином ЛРП $u$, имеющий наименьшую степень, назовем ее \textit{минимальным многочленом}, а его степень -- \textit{линейной сложностью }ЛРП $u$.

Минимальные многочлены ЛРП, а также их линейная сложность, являются важными характеристиками ЛРП. 

\textbf{Определение 5. }Пусть $u$ -- последовательность над полем $K$. Обозначим через $u\left(\overline{0,l-1}\right)=(u(0),\; ...\; ,u(l-1))$начальный отрезок $u$. Будем говорить, что многочлен

\[G(x)=x^{m} -\sum _{j=0}^{m-1}b_{j} \cdot x^{j}  \] 
\textit{вырабатывает отрезок }$u\left(\overline{0,l-1}\right)$, если 

\[\forall i\in [0,l-m-1]:\; u(i+m)=\sum _{j=0}^{m-1}b_{j} \cdot u(i+j) ,\] 
то есть если данный отрезок последовательности является отрезком некоторой ЛРП с характеристическим многочленом $G(x)$. 

 Естественным образом определяется понятие линейной сложности отрезка последовательности как минимальной степени из всех полиномов, вырабатывающих данный отрезок.

Далее будем рассматривать последовательности и многочлены над некоторым полем $K$. Алгоритм Берлекэмпа--Месси строит многочлен $G(x)$ наименьшей степени, вырабатывающий отрезок $u\left(\overline{0,l-1}\right)$. Чтобы перейти к непосредственному описанию алгоритма, требуется ввести еще ряд технических определений.

\textbf{Определение 6. }Пусть $H(x)=\sum _{j=0}^{n}h_{j} x^{j}  $ -- произвольный многочлен, а $v$ -- последовательность. Определим операцию умножения многочлена на последовательность, результатом которой будет последовательность, такая что:

\[H(x)\cdot u=w\] 

\[w(i)=\sum _{j=0}^{n}h_{j} \cdot v(i+j) \] 

Очевидно, операция является линейной относительно полинома, входящего в нее.

Для нормированного полинома $G(x)$ определим параметры: 

\begin{enumerate}
\item  $k_{u} (G)$ -- количество лидирующих нулей последовательности $G(x)\cdot u$ или $\infty $, если эта последовательность нулевая;

\item  $l_{u} (G)=k_{u} (G)+\deg (G)$.
\end{enumerate}

Легко убедиться, что $l_{u} (G)$ -- максимальная длина начального отрезка $u$, вырабатываемого $G(x)$. Действительно, пусть

\[G(x)=\sum _{j=0}^{m}g_{j} \cdot x^{j} = x^{m} -\sum _{j=0}^{m-1}b_{j} \cdot x^{j}  , G(x)\cdot u=v, \] 
тогда: $\forall i\in [0,l_{u} (G)-m-1]:v(i)=0$, но:

\[0=v(i)=\sum _{j=0}^{n}g_{j} \cdot u(i+j)=u(i+m)-\sum _{j=0}^{m-1}b_{j} \cdot u(i+j)  ,\] 
что и дает искомое:

\[\forall i\in [0,l_{u} (G)-m-1]:u(i+m)=\sum _{j=0}^{m-1}b_{j} \cdot u(i+j) .\] 

Как было отмечено, существует множество вариаций исследуемого алгоритма, приведенное ниже изложение основано на [4]. Зададимся последовательностью $u$ и числом $l$, найдем минимальный полином, вырабатывающий отрезок $u\left(\overline{0,l-1}\right)$. Будем строить последовательность нормированных полиномов $G_{0} (x),\; G_{1} (x),\; \ldots $ неубывающих степеней $0=m_{0} <m_{1} \le m_{2} \le \ldots $ в соответствии с нижеследующей структурной схемой.

\noindent \eject ulG_{0} (x):=1l_{0} :=l_{u} (G_{0} )G_{1} (x):=x^{k_{0} +1} -u_{0} (k_{0} +1)\cdot u_{0} (k_{0} )^{-1} \cdot G_{0} (x)l_{1} :=l_{u} (G_{1} )t:=1l_{0} <ll_{t} <lsk_{t} >k_{s} l_{t+1} :=l_{u} (G_{t+1} )t\_ :=t+1G(x)\_ :=G_{t} (x)G(x)ulG_{0} (x):=1l_{0} :=l_{u} (G_{0} )G_{1} (x):=x^{k_{0} +1} -u_{0} (k_{0} +1)\cdot u_{0} (k_{0} )^{-1} \cdot G_{0} (x)l_{1} :=l_{u} (G_{1} )t:=1l_{0} <ll_{t} <lsk_{t} >k_{s} l_{t+1} :=l_{u} (G_{t+1} )t\_ :=t+1G(x)\_ :=G_{t} (x)G(x)

\noindent 

\noindent 

\[25\] 


\noindent 

Обоснование алгоритма Берлекэмпа--Месси  содержится в [4], но ряд его элементов в этой работе опущен. Приведенные ниже рассуждения восполняют эти пробелы. Обоснование алгоритма проведем с помощью доказательства ряда лемм.

\textbf{Лемма 1. }Пусть даны целое число $r$, полином\textbf{ }$G(x)=\sum _{j=0}^{m}g_{j} \cdot x^{j}  $ и последовательность $u$, удовлетворяющие условию $r\le k_{u} (G)$. Тогда для полинома $\widetilde{G}(x)=x^{r} \cdot G(x)$ имеет место равенство:

\[k_{u} (\widetilde{G})=k_{u} (G)-r.\] 

\textbf{Доказательство.} Обозначим: 

\[k=k_{u} (G), \widetilde{k}=k_{u} (\widetilde{G}), G(x)\cdot u=v, \widetilde{G}(x)\cdot u=\tilde{v}.\] 
Пусть $\widetilde{G}(x)=x^{r} \cdot G(x)=\sum _{j=0}^{m+r}\tilde{g}_{j} \cdot x^{j}  $, где

\[\tilde{g}=\left\{\begin{array}{l} {0,\; 0<i<r,} \\ {g_{i-r} ,\; r\le i\le m+r.} \end{array}\right. \] 
Тогда:

\[\tilde{v}(i)=\sum _{j=0}^{m+r}\tilde{g}_{j} \cdot u(i+j)= \sum _{j=r}^{m+r}g_{j-r} \cdot u(i+j)=[s=j-r]= \sum _{s=0}^{m}g_{s} \cdot u(i+s+r)=v(i+r) .\] 
Если $r=k$, то $\tilde{v}(0)=v(r)=v(k)\ne 0$ (определение $k$), иначе, так как $\forall i\in [0,k-1]:v(i)=0$, то $\forall i\in [0,k-r-1]:v(i+r)=0$, тогда:

\[\forall i\in [0,k-r-1]:\tilde{v}(i)=0.\] 
Последнее, с учетом того, что $\tilde{v}\left(\tilde{k}\right)=\tilde{v}(k-r)=v(k)\ne 0$, и означает $\widetilde{k}=k-r$. Лемма доказана. 

\textbf{Лемма 1'. }Пусть даны полиномы\textbf{ $F(x)$,} $G(x)$ и последовательность $u$, удовлетворяющие условию $\deg \left(F(x)\right)\le k_{u} (G)$. Тогда для полинома $\widetilde{G}(x)=F(x)\cdot G(x)$ имеет место равенство:

\[k_{u} (\widetilde{G})=k_{u} (G)-\deg \left(F(x)\right).\] 

 \textbf{Доказательство. }Следует из леммы 1 и линейности операции умножения полинома на последовательность.

Корректность алгоритма будет определяться двумя фактами: полином, получающийся на каждом шаге, во-первых, вырабатывает более длинный отрезок последовательности $u$, чем предыдущий, во-вторых, имеет наименьшую степень из всех полиномов, вырабатывающих отрезок данной длины.

\textbf{Лемма 2. }В ходе описанного алгоритма $l_{u} (G_{t} )$ возрастает, и степень полиномов $m_{t} $ не убывает.

\textbf{Доказательство. }Индукция по $t$:

\[1) t=0: m_{1} =k_{0} +1>m_{0} =0, l\_ _{1} =k_{1} +m_{1} =k_{1} +k_{0} +1>l_{0} \_ =k_{0} +m_{0} =k_{0} .\] 

2) Предположим: $\forall t\quad t<t':\; l_{t+1} >l_{t} ,\; m_{t+1} \ge m_{t} $.

3) Пусть $t=t'$, а $s$ выбрано указанным в алгоритме образом, покажем $m_{t'+1} \ge m_{t'} $. В случае $k_{t} >k_{s} $, очевидно, $m_{t'+1} >m_{t'} $. В другом случае степень $G_{t'+1} (x)$ совпадает со степенью $G_{t'} (x)$, так как последняя удовлетворяет соотношению: $(\deg G_{t'} (x)=)m_{t'} >k_{s} -k_{t'} +m$ ($m_{t'} +k_{t'} =l_{t'} >l_{s} =m_{s} +k_{s} $ -- предположение индукции), то есть превосходит степень второго слагаемого, составляющего $G_{t'+1} (x)$. 

Индукция завершена и лемма доказана.

\textbf{Лемма 3. }Пусть дана последовательность $u$, $m$ -- линейная сложность ее отрезка длины $r$, $F(x)$ -- полином степени $m$, такой что:

\[l_{u} (F)\ge r,\] 
$H(x)$ -- полином степени $n$, такой что:

\[l_{u} (H)>l_{u} (F),\] 
тогда:

\[n\ge \max \left\{m,\; k_{u} (F)+1\right\}.\] 

\textbf{Доказательство. }Поскольку $l_{u} (H)>r$ , то $n>m$. Остается показать, что $n\ge k_{u} (F)+1$. Предположим противное: $n\le k_{u} (F)$. Тогда в соответствии с леммой 1' последовательность $w=H(x)\cdot F(x)\cdot u$ имеет в точности $k_{u} (F)-n$ лидирующих нулей. С другой стороны, $w=F(x)\cdot H(x)\cdot u$; покажем, что выполнены условия леммы 1':

\[k_{u} (H)=l_{u} (H)-n>l_{u} (F)-n\ge l_{u} (F)-k_{u} (F)=m,\] 
то есть, действительно, $k_{u} (F)>m$. Таким образом, можно утверждать, что последовательность $w$ имеет $k_{u} (x)-m$ лидирующих нулей. Тогда $k_{u} (H)+n=k_{u} (F)+m$. Окончательно имеем:

\[l_{u} (H)=k_{u} (H)+n=k_{u} (F)+m=l_{u} (F),\] 
что противоречит условию леммы. Доказательство леммы завершено.

\textbf{Лемма 4. }Степени полиномов, порождаемых алгоритмом, удовлетворяют условию:

\[m_{t+1} =\max \left\{m_{t} ,k_{t} +1\right\}.\] 

\textbf{Доказательство.} Индукция по $t$: 

1) $t=0$: очевидно.

2) Предположим $\forall t\quad t<t':\; m_{t+1} =\max \left\{m_{t} ,k_{t} +1\right\}$.

3) Пусть $t=t'$, а $s$ выбрано указанным в алгоритме образом, покажем, что $m_{t'+1} =\max \left\{m_{t'} ,k_{t'} +1\right\}$. Согласно предположению индукции $m_{s+1} =\max \left\{m_{s} ,k_{s} +1\right\}$, а так как $m_{t'} =m_{s+1} >m_{s} $, то $m_{t'} =k_{s} +1$. Как видно из рассуждений, проведенных при доказательстве леммы~2, степени полиномов изменяются следующим образом: если $k_{t'} \le k_{s} $, то $m_{t'+1} =m_{t'} $, иначе $m_{t'+1} =m_{t'} +k_{t'} -k_{s} $. Таким образом, в случае $k_{t'} \le k_{s} $,  необходимо показать, что $m_{t'} \ge k_{t'} +1$. И действительно, $m_{t'} =k_{s} +1\ge k_{t'} +1$. В случае же $k_{t'} >k_{s} $:

\[m_{t'} <m_{t'+1} =m_{t'} +k_{t'} -k_{s} =k_{s} +1+k_{t'} -k_{s} =k_{t'} +1.\] 
Тем самым индукция завершена и лемма доказана.

\textbf{Теорема 1.} Изложенный алгоритм строит многочлен минимальной степени, вырабатывающий отрезок последовательности $u$ длины не меньше чем $l$.

\textbf{Доказательство.} В силу леммы 2 для любого конечного наперед заданного $l$ за конечное число шагов на выходе алгоритма получается полином $G(x)$, для которого $l_{u} (G)\ge l$. Его степень удовлетворяет точной нижней границе для степеней всех полиномов, вырабатывающих отрезок не короче $l$ (леммы 3 и 4).

\noindent \eject 3. Реализация алгоритма Берлекэмпа--Месси

Алгоритм Берлекэмпа--Месси реализован на языке программирования С++ в соответствии со стандартом языка [6] с применением объектно-ориентированной методологии. В процессе работы над реализацией алгоритма была использована свободно распространяемая интегрированная среда разработки Microsoft Visual C++ 2005 Express Edition. 

В работе также использовалась библиотека с открытыми исходными кодами Schifra Reed-Solomon Error Correcting Code Library [7], распространяемая для академического и некоммерческого использования под лицензией GNU General Public License (версия 2) [8], которая обеспечивает арифметику полей Галуа и базовые операции с полиномами. Библиотека предусматривает работу в расширениях конечных полей характеристики два и хранит список примитивных над $F_{2} $ полиномов степени вплоть до шестнадцатой включительно. Последнее означает, что без дополнительных данных работа алгоритма поддерживается в полях мощности не более чем~$2^{16} $.

Математический аппарат, построенный во второй главе, отображается в программную модель с точностью до одного момента. Ограниченность памяти компьютера приводит к невозможности оперировать с бесконечными последовательностями, потому понятие линейной рекуррентной последовательности было замещено понятием \textit{линейного регистра сдвига }(ЛРС). ЛРС хранит \textit{множители}, соответствующие элементам $f_{0} ,\; ...\; ,f_{m-1} $ из определения ЛРП, и текущий отрезок последовательности (длины $m$), необходимый для вычисления каждого последующего элемента ЛРП в соответствии с линейным рекуррентным соотношением, называемый \textit{состоянием}. Использование ЛРС  позволит получать необходимые отрезки ЛРП.

Некоторые менее существенные детали реализации были скорректированы по сравнению с изложенным в главе 2, опираясь на [5].

\noindent 3.1. Архитектура реализации

В реализации предусмотрено два класса для основных сущностей задачи: класс линейного регистра сдвига и собственно класс алгоритма. Также разработан ряд свободных функций и классов, предназначенных для тестирования. Основные два класса проекта имеют слабое зацепление: единственная информация, которую им следует разделять --- фиксированный тип контейнера элементов поля (GFElementsContainer, описан в файле utilities.hpp).

Ниже приведен перечень файлов, содержащих исходный код, с кратким описанием их назначения:

\begin{enumerate}
\item  LFSR.cpp (LFSR.hpp) --- класс линейного регистра сдвига;

\item  BM-algorithm.cpp (BM-algorithm.hpp) --- класс, реализующий алгоритм вместе со вспомогательным вложенным классом Monoms (см. п. 3.3);

\item  utilities.hpp --- средства, необходимые для взаимодействия основных классов программы;

\item  galois/* --- средства библиотеки Schifra, ответственные за арифметику в полях Галуа и операции с полиномами над ними;

\item   test/* --- тесты для основных частей программы;

\item  main.cpp --- точка входа в программу.
\end{enumerate}

В исходном коде присутствуют отладочные секции, которые компилируются только при наличии определения макроса DEBUG; его следует опускать в release-сборке.

\noindent \eject 3.2. Класс линейного регистра сдвига

Класс LFSR (Linear Feedback Shift Register --- регистр сдвига с линейной обратной связью) предназначен для программного моделирования ЛРС, который, как сказано выше, является всего лишь особым представлением ЛРП. Его цель заключается в проверке корректности работы алгоритма: полученный на выходе алгоритма полином, дополненный последовательностью элементов, выполняющей функцию, аналогичную начальному отрезку ЛРС, используется для построения экземпляра класса LFSR. Далее появляется возможность получить произвольный отрезок последовательности, моделируемой данным экземпляром класса LFSR, посредством последовательных вызовов экземплярной функции operator() и убедиться таким образом, что полученный полином действительно является характеристическим полиномом последовательности, начальный отрезок которой совпадает с начальным отрезком последовательности, заданным алгоритму.

У данного класса имеется набор конструкторов, позволяющих корректно инициализировать два ключевых поля: кортежи множителей и состояния. Кортеж множителей реализован шаблоном стандартной библиотеки С++ vector$<$T$>$, параметризованным типом элемента поля Галуа field\_element; его размер фиксирован и не изменяется на протяжении жизни объекта. Для кортежа состояния более приемлемым показалось использование шаблона стандартной библиотеки С++ deque$<$T$>$ --- очередь с двумя концами: на каждом такте работы LFSR (то есть после каждого вызова функции operator())  вычисляется очередной элемент ЛРП, который добавляется в конец кортежа состояния, а клиенту возвращается элемент из начала этого кортежа. Таким образом размер очереди также остается неизменным.

Для класса LFSR предусмотрен оператор вывода в поток, обеспечивающий возможность печати содержимого объекта данного класса.

\noindent 3.3. Класс алгоритма

В классе алгоритма BMAlgorithm реализованы основные операции, использованные при изложении алгоритма Берлекэмпа --- Месси, как-то: умножение полинома на последовательность и подсчет количества лидирующих нулей в последовательности. После создания экземпляра класса (конструктор принимает лишь ссылку на объект класса field, представляющего конечное поле, в котором производятся вычисления), его запуск производится посредством вызова функции-члена operator(); в качестве единственного аргумента указанной функции передается отрезок ЛРП, для которого необходимо построить минимальный многочлен.

Описанный в главе 2 алгоритм непосредственно выполняется в теле функции operator(). Шаги алгоритма отображаются на операторы языка программирования почти дословно.

В ходе алгоритма возникает необходимость многократно вычислять мономы различных степеней (выражения вида $x^{r} $). С целью оптимизации этого действия был создан класс Monoms, объявленный внутри класса BMAlgorithm и являющийся тривиальной оберткой шаблона стандартной библиотеки С++ map$<$T$>$. Объект этого класса создается вместе с экземпляром класса BMAlgorithm, он кэширует мономы, вычисленные на предыдущих шагах работы алгоритма, и в ответ на запрос монома конкретной степени (вызов функции operator[]) либо возвращает ссылку на константу (такого уровня доступа оказывается достаточно, учитывая что мономы используются при расчете арифметических выражений), вычисленную ранее, либо вычисляет требуемое значение, добавляет в свою коллекцию и также возвращает ссылку на константу.

Стоит заметить, что выразительность, достигнутая широким использованием перегруженных арифметических операторов, как и обычно в языке С++, не обходится даром --- в ходе работы алгоритма создается большое количество временных объектов. Возможным путем избежать накладных расходов, связанных с этим, является использование техники Expression Templates, описанной, например, в [9]. Впрочем, это потребовало бы существенного вмешательства в исходный код библиотеки, что выходит за рамки поставленных задач. 

\noindent 3.4. Тестирование

Хотя практически весь исходный код был в той или иной степени покрыт набором тестов, основным объектом тестирования стал, конечно, класс BMAlgorithm. Здесь же стоит отметить, что корректность библиотечных средств также была установлена при помощи написания отдельного ряда тестов. Для основного класса программы было предусмотрено два основных тестовых случая:

\begin{enumerate}
\item  длинная псевдослучайная последовательность;

\item  все возможные последовательности заданной длины (учитывая, что вычисления проводятся в конечных полях, количество таких последовательностей конечно).
\end{enumerate}

Для запуска проверки указанных тестовых случаев созданы две свободных функции: totalSequencesTesting(), testLongSequence(). Для реализации обеих проверок  был использован класс SequenceTester, описание которого приведено ниже.

Назначение класса SequenceTester --- предоставить средства проверки корректности работы алгоритма на одной заданной последовательности. Проверка запускается вызовом метода testSequence(), в качестве аргумента которому передается тестовая последовательность. Далее логика работы такова: 

\noindent \begin{enumerate}
\item 4) )построение с помощью имеющегося у каждого объекта-теста экземпляра алгоритма минимального полинома для данной последовательности;

\noindent \item 5) )создание ЛРС (объекта LFSR) на основе полученного полинома;

\noindent \item 6) )проверка на равенство исходной последовательности и той, которую генерирует ЛРС.
\end{enumerate}

Класс способен регистрировать два вида ошибок, что отражено в наличии объявленного внутри SequenceTester перечисления FailureReason:

\begin{enumerate}
\item  п.1 завершается неудачей: зацикливание при работе алгоритма (в процессе создания полинома выбрасывается исключение) --- константа ENDLESS\_LOOP;

\item  п.3 завершается неудачей: получаемая на выходе ЛРС последовательность не совпадает с исходной --- константа NOT\_MATCH.
\end{enumerate}

При возникновении одной из двух указанных ситуаций, тестируемая последовательность вместе с кодом ошибки заносится в коллекцию ошибок, хранимую объектом теста. Клиент класса может осведомиться о наличии ошибок, вызвав метод hasFailures() и, если таковые имеются, вывести их на консоль.

Если случай единственной, произвольно длинной (с учетом естественных ограничений вычислительных ресурсов) псевдослучайной последовательности не представил особых препятствий  в реализации (все свелось к последовательным вызовам стандартной библиотечной функции rand() и передаче полученной последовательности объекту SequenceTester), то генерация всех последовательностей заданной длины является известной комбинаторной задачей, функционал которой был вынесен в отдельный класс --- SequencesGenerator, при этом возникла необходимость принять не слишком привлекательное в отношении дизайна тестового модуля решение. Поскольку работа генератора строится из последовательных рекурсивных вызовов одной функции (sequencesGenerating()), то каждый раз возвращать клиенту очередную построенную последовательность не удается. Возможны два варианта: предлагать в качестве результата работы основного интерфейсного метода класса (operator()) набор из всех последовательностей и затем, для каждого элемента такого набора вызывать тестовый метод класса SequenceTester --- но это вызвало бы большие затраты памяти; либо вызывать упомянутый тестовый метод прямо в процессе генерации, внутри объекта класса SequencesGenerator. В итоге был реализован второй вариант: объект класса-генератора владеет экземпляром SequenceTester и вызывает его тестовый метод по мере формирования каждой следующей последовательности. Следует отметить, что в современных языках программирования имеются средства получать промежуточные результаты работы рекурсивных функций без полной раскрутки стека вызовов (например, инструмент generators в языке Python).

\noindent 

\noindent \eject 4. Декодер для кодов Рида--Соломона

Как уже было отмечено во введении, алгоритм Берлекэмпа--Месси имеет многочисленные применения. Однако наиболее важным с практической точки зрения представляется использование данного алгоритма в качестве конструктивного элемента декодера кодов Рида--Соломона. Ниже приведено определение кодов Рида--Соломона и описание декодера [10].

\textbf{Определение 1. }\textit{Линейным кодом длины $n$ размерности $k$ }называется $k$-мерное подпространство линейного векторного пространства $F_{q} ^{n} $.

\textbf{Определение 2. }\textit{Кодом Рида--Соломона }размерности $k$ называется линейный код длины $n=q-1$, изоморфный идеалу $I=\left(g(x)\right)$ факторкольца ${F_{q} ^{n} [x]\mathord{\left/ {\vphantom {F_{q} ^{n} [x] (x^{n} -1)}} \right. \kern-\nulldelimiterspace} (x^{n} -1)} $, где:

\[g(x)=(x-\alpha )(x-\alpha ^{2} )...(x-\alpha ^{n-k} ),\] 
$\alpha $ --- примитивный элемент $F_{q} ^{n} $.

Можно показать, что коды Рида---Соломона являются МДР-кодами, то есть имеют минимальное кодовое расстояние $d=n-k+1$ и, таким образом, исправляют не более $t=\left\lfloor \frac{n-k}{2} \right\rfloor $ ошибок.

Информационное сообщение --- вектор длины $k$ над $F_{q} ^{n} $ представляется в виде полинома $f(x)$степени не выше $k-1$. Кодирование производится посредством умножения:

\[c(x)=f(x)\cdot g(x).\] 

По каналу приходит слово $v(x)$, в котором имеется аддитивная ошибка $e(x)=\sum _{i=0}^{n-1}e_{i} \cdot x^{i}  $:

\[r(x)=c(x)+e(x).\] 

Задача декодера --- вычислить $e(x)$.

После получения слова из канала декодер вычисляет компоненты \textit{синдрома} $S_{j} $ по формуле:

\[\forall j\in [1,n-k]:\; S_{j} =r(\alpha ^{j} ),\] 
заметим, что $r(\alpha ^{j} )=e(\alpha ^{j} )$. То есть:

\[\forall j\in [1,n-k]:\; S_{j} =\sum _{i=0}^{n-1}e_{i} \cdot \alpha ^{i\cdot j}  .\] 
Если все компоненты равны нулю, то считается, что ошибок не произошло.

Определим \textit{локаторы ошибок} $x_{j} $ и \textit{величины ошибок} $y_{j} $следующим образом:

\[\forall j\in [1,\nu ]:\; x_{j} =\alpha ^{a_{j} } ,\; y_{j} =e_{a_{j} } ,  a_{j} \in \{ i|e_{i} \ne 0\} .\] 
Тогда для $S_{j} $ получим систему уравнений:

\[\forall j\in [1,n-k]:\; S_{j} =\sum _{i=0}^{\nu }y_{i} \cdot x_{i}^{j}   (*)\] 

Декодер работает в предположении, что в канале произошло не более чем $t$ ошибок, в таком случае: $\nu \le t$.

Получившаяся система выглядит пессимистично: неизвестны $y_{i} $, $x_{i} $, $\nu $. Будем находить сначала $x_{i} $ и $\nu $. Введем еще один вспомогательный объект --- \textit{полином локаторов ошибок} $\sigma (z)$:

\[\sigma (z)=(z-x_{1} )(z-x_{2} )\ldots (z-x_{\nu } )=z^{\nu } +\sum _{i=1}^{\nu -1}\sigma _{i} z^{i}  .\] 
Запишем для $\forall i\in [1,\nu ],\; \forall j\in [1,n-k]$:

\[0=y_{i} \cdot x_{i}^{j} \cdot \sigma (x_{i} )=y_{i} \cdot x_{i}^{j+\nu } +\sigma _{1} \cdot y_{i} \cdot x_{i}^{j+\nu -1} +\ldots +\sigma _{\nu } \cdot y_{i} \cdot x_{i}^{j} .\] 
Просуммировав по $i$, находим:

\[\forall j\in [1,n-k]:\; 0=\sum _{i=1}^{\nu }y_{i} \cdot x_{i}^{j+\nu }  +\sigma _{1} \cdot \sum _{i=1}^{\nu }y_{i} \cdot x_{i}^{j+\nu -1}  +\ldots +\sigma _{\nu } \cdot \sum _{i=1}^{\nu }y_{i} \cdot x_{i}^{j}  ,\] 
или:

\[\forall j\in [1,n-k]:\; S_{j+\nu } =-\sigma _{1} \cdot S_{j+\nu -1} -\ldots -\sigma _{\nu } \cdot S_{j} .\] 
Последнее можно представить в матричном виде:

\[\left(\begin{array}{cccc} {S_{1} } & {S_{2} } & {\ldots } & {S_{\nu } } \\ {S_{2} } & {S_{3} } & {\ldots } & {S_{\nu +1} } \\  \hline {S_{n-k} } & {S_{n-k+1} } & {\ldots } & {S_{n-k+\nu -1} } \end{array}\right)\cdot \left(\begin{array}{c} {-\sigma _{\nu } } \\ {-\sigma _{\nu -1} } \\  \hline {-\sigma _{1} } \end{array}\right)=\left(\begin{array}{c} {S_{\nu +1} } \\ {S_{\nu +2} } \\  \hline {S_{n-k+\nu } } \end{array}\right)\] 


В действительности имеется $n-k$ компонент синдрома, потому последние $\nu $ уравнений не рассматриваются. Система примет вид:

\[\left(\begin{array}{cccc} {S_{1} } & {S_{2} } & {\ldots } & {S_{\nu } } \\ {S_{2} } & {S_{3} } & {\ldots } & {S_{\nu +1} } \\  \hline {S_{n-k-\nu } } & {S_{n-k-\nu +1} } & {\ldots } & {S_{n-k-1} } \end{array}\right)\cdot \left(\begin{array}{c} {-\sigma _{\nu } } \\ {-\sigma _{\nu -1} } \\  \hline {-\sigma _{1} } \end{array}\right)=\left(\begin{array}{c} {S_{\nu +1} } \\ {S_{\nu +2} } \\  \hline {S_{n-k} } \end{array}\right).\] 

Можно показать, что матрица этой системы -- назовем ее $M$ -- неввырождена в том случае, если в канале произошло ровно $\nu $ ошибок (полином $e(x)$ имеет $\nu $ ненулевых коэффициентов), и вырождена, если ошибок меньше. Это условие дает способ нахождения $\nu $.

Как видно, полученная система задает отрезок линейной рекуррентной последовательности $S(i)$, множители $-\sigma _{j} $ которой могут быть найдены с помощью алгоритма Берлекэмпа---Месси. Таким образом может быть найден полином локаторов ошибок $\sigma (z)$.

Далее находятся корни $\sigma (z)$ --- как правило, с помощью перебора элементов поля $F_{q} $ (\textit{процедура Ченя}). Затем решается система (*) --- существуют эффективные методы ее решения, например, \textit{алгоритм Форни}. После этого уже может быть восстановлен $e(x)$. Окончательно, общая схема декодера, носящего имена Питерсона, Горенстейна и Цирлера, может быть представлена следующим образом.

r(x)e(x)\forall j\in [1,n-k]:\; S_{j} :=r(\alpha ^{j} )\nu :=tM:=\left(\begin{array}{ccc} {S_{1} } & {\ldots } & {S_{\nu } } \\  \hline {S_{n-k-\nu } } & {\ldots } & {S_{n-k-1} } \end{array}\right)\det (M)=0\nu :=\nu -1\sigma (z)---x_{i} \sigma (z)\forall j\in [1,n-k]:\; S_{j} =\sum _{i=0}^{\nu }y_{i} \cdot x_{i}^{j}  y_{i} e(x)x_{i} y_{i} r(x)e(x)\forall j\in [1,n-k]:\; S_{j} :=r(\alpha ^{j} )\nu :=tM:=\left(\begin{array}{ccc} {S_{1} } & {\ldots } & {S_{\nu } } \\  \hline {S_{n-k-\nu } } & {\ldots } & {S_{n-k-1} } \end{array}\right)\det (M)=0\nu :=\nu -1\sigma (z)---x_{i} \sigma (z)\forall j\in [1,n-k]:\; S_{j} =\sum _{i=0}^{\nu }y_{i} \cdot x_{i}^{j}  y_{i} e(x)x_{i} y_{i} 5. Литература

\begin{enumerate}
\item  Berlekamp E. R. Algebraic Coding Theory. -- New York: McGrow Hill, 1968 (перевод: Берлекэмп Э. Алгебраическая теория кодирования. -- М.: Мир, 1971).

\item  Massey J.L., Shift Register Synthesis and BCH Decoding, // IEEE Trans. Inform. Theory. ---  vol. IT-15, no. 1, 1969.

\item  Куракин. Алгоритм Берлекэмпа-Месси над коммутативными артиновыми кольцами главных идеалов // Фундаментальная и прикладная математика. --- Том 5, вып. 4, 1999.

\item  V. L. Kurakin, A. S. Kuzmin, A. V. Mikhalev, A. A. Nechaev. Linear recurring sequences over rings and modules. // I. of Math. Science. Contemporary Math. and it's Appl. Thematic surveys, vol. 10, 1994, I. of Math. Sciences, vol. 76, № 6, 1995.

\item  Алферов А.П., Зубов А.Ю., Кузьмин А.С., Черемушкин А.В. Основы криптографии: учебное пособие. 3-е изд., испр. и доп. --- М.: Гелиос~АРВ, 2005.

\item  ISO Information Technology --- Programming Languages --- C++ Document Number ISO/IEC 14882-1998 ISO/IEC, 1998.

\item  Schifra Reed-Solomon Error Correcting Code Library, http://www.schifra.com/.

\item  The GNU General Public License (GPL), Version 2, June 1991, http://www.opensource.org/licenses/gpl-license.php.

\item  Vandevoorde, D., N.M. Josuttis. C++ Templates. CityplaceBoston: Addison-Wesley, 2003. ISBN 0201734842 (перевод: Вандевурд Д., Джосаттис Н. Шаблоны С++: справочник разработчика. --- М.: Издательский дом «Вильямс», 2003).

\item  Блейхут Р. Теория и практика кодов, контролирующих ошибки: Пер. с англ. --- М.: Мир, 1986.
\end{enumerate}

 \textit{  Приложение}

\noindent 

\noindent 

\[36\] 


\noindent Приложение 

\noindent Класс линейного регистра сдвига

\begin{enumerate}
\item  \textbf{LFSR.hpp}
\end{enumerate}

\noindent \#ifndef LFSR\_HPP

\noindent \#define LFSR\_HPP

\noindent 

\noindent \#include "utilities.hpp"

\noindent \#include "galois\textbackslash schifra\_galois\_field.hpp"

\noindent \#include "galois\textbackslash schifra\_galois\_field\_polynomial.hpp"

\noindent \#include $<$vector$>$

\noindent \#include $<$deque$>$

\noindent \#include $<$cstddef$>$

\noindent \#include $<$cstdlib$>$

\noindent \#include $<$algorithm$>$

\noindent \#include $<$iostream$>$

\noindent \#include $<$iterator$>$

\noindent 

\noindent using namespace schifra::galois;

\noindent using std::vector;

\noindent using std::deque;

\noindent using std::size\_t;

\noindent using std::back\_inserter;

\noindent using std::ostream;

\noindent 

\noindent class LFSR \{    

\noindent 

\noindent     typedef vector$<$field\_element$>$ MultipliersContainer;

\noindent     typedef deque$<$field\_element$>$ StateContainer;

\noindent 

\noindent     MultipliersContainer multipliers;

\noindent     StateContainer state;

\noindent     

\noindent public:

\noindent     

\noindent     LFSR( field\_element* const \_muls, field\_element* const \_st, const size\_t size ) \{

\noindent         multipliers.reserve( size );

\noindent                 

\noindent         std::copy( \_muls, \_muls + size, back\_inserter( multipliers ) );

\noindent         std::copy( \_st, \_st + size, back\_inserter( state ) );

\noindent         

\noindent     \}

\noindent 

\noindent     LFSR( const field\_polynomial\& poly, field\_element* \_st );

\noindent     

\noindent     LFSR( const field\_polynomial\& poly, const GFElementsContainer\& \_st );

\noindent     

\noindent     LFSR( field\& \_gf ) : multipliers( 1, field\_element( \&\_gf, 0) ), 

\noindent                         state( 1, field\_element( \&\_gf, 0) ) \{\}

\noindent     

\noindent     field\_element operator()();

\noindent     

\noindent     size\_t length() const \{

\noindent         return multipliers.size();

\noindent     \}

\noindent     

\noindent     void setState( const StateContainer\& newstate ) \{

\noindent         state = newstate;

\noindent     \}

\noindent     

\noindent     friend ostream\& operator$<$$<$( ostream\& os, const LFSR\& lfsr );

\noindent \};

\noindent 

\noindent ostream\& operator$<$$<$( ostream\& os, const LFSR\& lfsr );

\noindent 

\noindent \#endif  // LFSR\_HPP

\begin{enumerate}
\item  \textbf{LFSR.cpp}
\end{enumerate}

\noindent \#include "LFSR.hpp"

\noindent \#include $<$algorithm$>$

\noindent \#include $<$numeric$>$

\noindent \#include $<$string$>$

\noindent \#include "galois\textbackslash schifra\_galois\_field\_element.hpp"

\noindent 

\noindent ostream\& operator$<$$<$( ostream\& os, const LFSR\& lfsr ) \{

\noindent     using namespace std;

\noindent     const size\_t width = 79;

\noindent     string boldline( width, '=' );

\noindent     // string line( width, '-' );

\noindent     

\noindent     cout $<$$<$ boldline $<$$<$ endl $<$$<$ "LFSR:" $<$$<$ endl $<$$<$ "size:\textbackslash t\textbackslash t" $<$$<$ lfsr.length() $<$$<$ endl;

\noindent     

\noindent     cout $<$$<$ "multipliers:\textbackslash t";

\noindent     copy( lfsr.multipliers.begin(), lfsr.multipliers.end(), ostream\_iterator$<$schifra::galois::field\_element$>$(cout," ") );

\noindent     

\noindent     cout $<$$<$ endl $<$$<$ "state:\textbackslash t\textbackslash t";

\noindent     copy( lfsr.state.begin(), lfsr.state.end(), ostream\_iterator$<$schifra::galois::field\_element$>$(cout," ") );

\noindent     

\noindent     cout $<$$<$ endl $<$$<$ boldline $<$$<$ endl;

\noindent     

\noindent     return os;

\noindent \}

\noindent 

\noindent field\_element LFSR::operator()() \{

\noindent     field\_element result( state.front() );

\noindent     const field\_element INIT( result.galois\_field(), 0 );

\noindent     

\noindent     field\_element newElement = std::inner\_product( state.begin(), state.end(), multipliers.begin(), INIT );

\noindent     

\noindent     state.push\_back( newElement );

\noindent     state.pop\_front();

\noindent     

\noindent     return result;

\noindent \}

\noindent 

\noindent LFSR::LFSR( const field\_polynomial\& poly, field\_element* \_st ) \{

\noindent     // it is assumed that the \_st points to poly.deg()-number of field\_elements 

\noindent     size\_t polydeg = poly.deg();

\noindent     const field\_element ZERO( poly.galois\_field(), 0 );

\noindent     multipliers.reserve( polydeg );

\noindent     

\noindent     for( size\_t i = 0; i $<$ polydeg; ++i, ++\_st ) \{

\noindent         multipliers.push\_back( ZERO - poly[i] );

\noindent         state.push\_back( *\_st );

\noindent     \}

\noindent \}

\noindent 

\noindent LFSR::LFSR( const field\_polynomial\& poly, const GFElementsContainer\& \_st ) \{

\noindent     // it is assumed that the \_st contains poly.deg()-number of field\_elements 

\noindent     size\_t polydeg = poly.deg();

\noindent     const field\_element ZERO( poly.galois\_field(), 0 );

\noindent     multipliers.reserve( polydeg );

\noindent  

\noindent     GFElementsContainer::const\_iterator stIter = \_st.begin();

\noindent     for( size\_t i = 0; i $<$ polydeg; ++i, ++stIter ) \{

\noindent         multipliers.push\_back( ZERO - poly[i] );

\noindent         state.push\_back( *stIter );

\noindent     \}

\noindent \}

\noindent Класс алгоритма

\begin{enumerate}
\item  \textbf{BM-algorithm.hpp}
\end{enumerate}

\noindent \#ifndef BM\_ALGORITHM\_HPP

\noindent \#define BM\_ALGORITHM\_HPP

\noindent 

\noindent \#include "utilities.hpp"

\noindent \#include "galois\textbackslash schifra\_galois\_field.hpp"

\noindent \#include "galois\textbackslash schifra\_galois\_field\_element.hpp"

\noindent \#include "galois\textbackslash schifra\_galois\_field\_polynomial.hpp"

\noindent \#include $<$vector$>$

\noindent \#include $<$map$>$

\noindent \#include $<$cstddef$>$

\noindent 

\noindent using std::size\_t;

\noindent 

\noindent using namespace schifra::galois;

\noindent 

\noindent class BMAlgorithm \{

\noindent 

\noindent public:

\noindent 

\noindent     BMAlgorithm( field\& \_gf ) :  gf(\_gf), monoms( gf ) \{\}

\noindent 

\noindent     GFElementsContainer polySeqProduct( const field\_polynomial\& poly, 

\noindent                                                     const GFElementsContainer\& seq );

\noindent     size\_t countLeadingZeroes( GFElementsContainer seq );

\noindent     

\noindent     field\_polynomial operator()( const GFElementsContainer\& seq );

\noindent     field\_polynomial operator()( field\_element* const gfes, size\_t size );

\noindent     

\noindent     class Monoms \{

\noindent     public:

\noindent         Monoms( field\& \_gf ) : gf(\_gf) \{

\noindent             field\_element gfes[] = \{ field\_element ( \&gf, 0 ), field\_element ( \&gf, 1 ) \};

\noindent             data[0] = field\_polynomial( \&gf, 0, gfes + 1 );

\noindent             data[1] = field\_polynomial( \&gf, 1, gfes );

\noindent         \}

\noindent         

\noindent         field\_polynomial const \& operator[]( size\_t degree );                

\noindent     

\noindent     private:

\noindent         typedef std::map $<$size\_t, field\_polynomial$>$ Container;

\noindent         field\& gf;

\noindent         Container data;

\noindent         

\noindent         void operator=( const Monoms\& );

\noindent     \};

\noindent     

\noindent private:

\noindent     field\& gf;

\noindent     Monoms monoms;

\noindent     

\noindent     // BMAlgorithm 

\noindent     void operator=( const BMAlgorithm\& );

\noindent     

\noindent \};

\noindent 

\noindent \#endif  // BM\_ALGORITHM\_HPP

\begin{enumerate}
\item  \textbf{BM-algorithm.cpp}
\end{enumerate}

\noindent \#include "BM-algorithm.hpp"

\noindent \#include "galois\textbackslash schifra\_galois\_field.hpp"

\noindent \#include "galois\textbackslash schifra\_galois\_field\_polynomial.hpp"

\noindent \#include $<$algorithm$>$

\noindent \#include $<$iterator$>$

\noindent \#include $<$fstream$>$

\noindent \#include $<$vector$>$

\noindent \#include $<$iostream$>$

\noindent \#include $<$utility$>$

\noindent \#include $<$limits$>$

\noindent \#include $<$stdexcept$>$

\noindent \#include $<$cassert$>$

\noindent \#include $<$cstddef$>$

\noindent 

\noindent using schifra::galois::field\_element;

\noindent using schifra::galois::field\_polynomial;

\noindent using std::size\_t;

\noindent 

\noindent static void printSequence( const GFElementsContainer\& seq, 

\noindent             std::ostream \&out = std::cout  );

\noindent 

\noindent GFElementsContainer BMAlgorithm::polySeqProduct( const field\_polynomial\& poly, 

\noindent                                                     const GFElementsContainer\& seq ) \{

\noindent     assert( poly.deg() $<$ (int)seq.size() );

\noindent     

\noindent     const size\_t poly\_deg = poly.deg();

\noindent     const size\_t res\_size = seq.size() - poly\_deg;

\noindent     

\noindent     

\noindent     GFElementsContainer result( res\_size );

\noindent 

\noindent     for ( size\_t i = 0; i $<$ res\_size; ++i ) \{

\noindent         result[i] = poly[0] * seq[i];

\noindent         for ( size\_t j = 1; j $<$= poly\_deg; ++j ) \{

\noindent             result[i] += poly[j] * seq[i + j];

\noindent         \}

\noindent     \}    

\noindent     

\noindent     return result;

\noindent \}

\noindent 

\noindent size\_t BMAlgorithm::countLeadingZeroes( GFElementsContainer seq ) \{

\noindent     size\_t res = 0;

\noindent     const field\_element ZERO( \&gf, 0 );

\noindent     while( res $<$ seq.size() \&\& seq[res] == ZERO )

\noindent         ++res;        

\noindent     // return (res == seq.size()) ? std::numeric\_limits$<$size\_t$>$::max() : res;

\noindent     return res;

\noindent \}

\noindent 

\noindent field\_polynomial const \& BMAlgorithm::Monoms::operator[]( size\_t degree ) \{

\noindent     Container::iterator it = data.find( degree );

\noindent     if ( it == data.end() ) \{

\noindent         field\_polynomial\& x = data[1];

\noindent         field\_polynomial result( x );

\noindent         for (size\_t i = 1; i $<$ degree; ++i) \{

\noindent             result *= x;

\noindent         \}

\noindent         return ( ( data.insert( std::make\_pair( degree, result ) ) ).first )-$>$second;

\noindent     \} else \{

\noindent         return it-$>$second;

\noindent     \}

\noindent \}

\noindent 

\noindent field\_polynomial BMAlgorithm::operator()( field\_element* const gfes, size\_t size ) \{

\noindent     GFElementsContainer seq;

\noindent     seq.reserve( size );

\noindent         

\noindent     std::copy( gfes, gfes + size, back\_inserter( seq ) );

\noindent 

\noindent     return (*this)(seq);

\noindent \}

\noindent 

\noindent field\_polynomial BMAlgorithm::operator()( const GFElementsContainer\& seq ) \{

\noindent     size\_t k\_old = 0, k = 0;

\noindent     size\_t step = 1, maxsteps = seq.size();

\noindent     const size\_t INFINITY = std::numeric\_limits$<$size\_t$>$::max();

\noindent     

\noindent     //std::cout $<$$<$ "Sequence: ";

\noindent     //std::copy( seq.begin(), seq.end(), 

\noindent     //        std::ostream\_iterator$<$field\_element$>$(std::cout, " ") );

\noindent     //std::cout $<$$<$ std::endl;

\noindent 

\noindent     k\_old = countLeadingZeroes( seq );

\noindent     // if ( k\_old == INFINITY )    // initial sequence is nullity

\noindent     if ( k\_old == seq.size() )

\noindent         return monoms[1];       // minimal polynomial "x" leads to LFSR with one multiplier - 0

\noindent         

\noindent     if ( k\_old == seq.size() - 1 )      // sequences like 0...0a with length n produced by

\noindent         return monoms[ seq.size() ];    // LFSR 0...0 whith length n - not shorter!

\noindent     

\noindent     field\_polynomial G\_old( \&gf );

\noindent     field\_polynomial G( \&gf );

\noindent     field\_polynomial G\_new( \&gf );

\noindent     

\noindent     try \{

\noindent         G\_old = monoms[0];

\noindent         G = monoms[k\_old + 1]

\noindent                         - seq[k\_old + 1] * seq[k\_old].inverse() * monoms[k\_old] * G\_old ;

\noindent         G\_new = G;

\noindent     \} catch (...) \{

\noindent         std::cout $<$$<$ "critical error" $<$$<$ std::endl;

\noindent     \}

\noindent     GFElementsContainer u, u\_old;

\noindent 

\noindent     u = polySeqProduct( G, seq );  u\_old = seq ;

\noindent     k = countLeadingZeroes( u );

\noindent     // std::ostream \&out = std::cout;

\noindent     // std::ofstream outf("D:/Coding/trace.txt");

\noindent     // std::ostream \&out = outf;    

\noindent     // while ( k != INFINITY ) \{

\noindent     while ( k + G.deg() $<$ seq.size() ) \{

\noindent         // std::cout $<$$<$ G.deg() $<$$<$ std::endl;

\noindent         if( step++ $>$ maxsteps )

\noindent             throw std::logic\_error("Too many iterations!");

\noindent         //if ( int(k) - int(k\_old) $>$ 1 ) \{

\noindent             //out $<$$<$ "G\_old:\textbackslash t" $<$$<$ G\_old $<$$<$ std::endl;

\noindent             //out $<$$<$ "G:\textbackslash t\textbackslash t" $<$$<$ G $<$$<$ std::endl;

\noindent             //out $<$$<$ "k\_old:\textbackslash t" $<$$<$ k\_old $<$$<$ std::endl;

\noindent             //out $<$$<$ "k:\textbackslash t\textbackslash t" $<$$<$ k $<$$<$ std::endl;

\noindent             //out $<$$<$ "u\_old:\textbackslash t";

\noindent             //printSequence(u\_old, out);

\noindent             //out $<$$<$ "u:\textbackslash t\textbackslash t";

\noindent             //printSequence(u, out);

\noindent             //out $<$$<$ "\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_";

\noindent             //out $<$$<$ std::endl;

\noindent         //\}

\noindent         field\_polynomial temp( u[k] * u\_old[k\_old].inverse() * G\_old );

\noindent         if ( k $<$= k\_old ) \{

\noindent             G\_new = G - monoms[k\_old - k] * temp;

\noindent         \} else \{

\noindent             G\_new = monoms[k - k\_old] * G - temp;

\noindent         \}

\noindent         assert( G\_new.deg() $>$= G.deg() );

\noindent         if ( G\_new.deg() $>$ G.deg() ) \{

\noindent             k\_old = k;

\noindent             u\_old = u;

\noindent             G\_old = G;

\noindent         \}

\noindent         G = G\_new;

\noindent         u = polySeqProduct( G\_new, seq );

\noindent         k = countLeadingZeroes( u );

\noindent     \}

\noindent     

\noindent     return G\_new;

\noindent \}

\noindent 

\noindent void printSequence( const GFElementsContainer\& seq, 

\noindent         std::ostream \&out ) \{

\noindent     copy( seq.begin(), seq.end(), 

\noindent             std::ostream\_iterator$<$field\_element$>$( out, " " ) );

\noindent     out $<$$<$ std::endl;

\noindent \}

\noindent Модуль тестирования алгоритма

\begin{enumerate}
\item  \textbf{testBM-Algorithm.hpp}
\end{enumerate}

\noindent \#ifndef TESTBM\_ALGORITHM\_HPP

\noindent \#define TESTBM\_ALGORITHM\_HPP

\noindent int testBMA();

\noindent \#endif  // TESTBM\_ALGORITHM\_HPP

\begin{enumerate}
\item  \textbf{testBM-Algorithm.сpp}
\end{enumerate}

\noindent \#include "testBM-Algorithm.hpp"

\noindent \#include "BM-Algorithm.hpp"

\noindent \#include "LFSR.hpp"

\noindent \#include "galois\textbackslash schifra\_galois\_field.hpp"

\noindent \#include "galois\textbackslash schifra\_galois\_field\_polynomial.hpp"

\noindent \#include "galois\textbackslash schifra\_galois\_field\_element.hpp"

\noindent \#include $<$algorithm$>$

\noindent \#include $<$utility$>$

\noindent \#include $<$iostream$>$

\noindent \#include $<$iomanip$>$

\noindent \#include $<$vector$>$

\noindent \#include $<$list$>$

\noindent \#include $<$iterator$>$

\noindent \#include $<$limits$>$

\noindent \#include $<$cstddef$>$

\noindent \#include $<$cstdlib$>$

\noindent \#include $<$stdexcept$>$

\noindent 

\noindent using namespace schifra::galois;

\noindent using std::copy;

\noindent using std::cout;

\noindent using std::endl;

\noindent using std::size\_t;

\noindent using std::ostream\_iterator;

\noindent 

\noindent unsigned int prim\_poly2[] = \{1, 1, 1\};

\noindent const unsigned int * prim\_poly3 = primitive\_polynomial00;

\noindent const unsigned int size = 3;

\noindent field gf ( 3, 3, prim\_poly3 );

\noindent const field\_element ZERO( \&gf, 0 );

\noindent BMAlgorithm alg( gf );

\noindent 

\noindent field\_element gfes[] = \{

\noindent         field\_element(\&gf,1),

\noindent         field\_element(\&gf,2),

\noindent         field\_element(\&gf,3),

\noindent         field\_element(\&gf,3),

\noindent         field\_element(\&gf,2),

\noindent         field\_element(\&gf,1),

\noindent         field\_element(\&gf,1),

\noindent         field\_element(\&gf,3),

\noindent         field\_element(\&gf,2),

\noindent         field\_element(\&gf,2),

\noindent         field\_element(\&gf,3),

\noindent         field\_element(\&gf,1)

\noindent         

\noindent \};    

\noindent 

\noindent field\_polynomial poly1( \&gf, 1, gfes ); // ( \&gf, 2, gfes);

\noindent 

\noindent int testPolySeqProduct();

\noindent int testCountLeadingZeroes();

\noindent int testMonoms();

\noindent int testAlg();

\noindent int totalSequencesTesting();

\noindent int testLongSequence();

\noindent void printSequence( const GFElementsContainer\& seq, 

\noindent             std::ostream \&out = std::cout  );

\noindent 

\noindent int testBMA() \{

\noindent     //testPolySeqProduct();

\noindent     //testCountLeadingZeroes();

\noindent     // testMonoms();

\noindent     // testAlg();

\noindent     totalSequencesTesting();

\noindent     // testLongSequence();

\noindent     return 0;    

\noindent \}

\noindent 

\noindent int testMonoms() \{

\noindent     BMAlgorithm::Monoms monoms( gf );

\noindent     for ( size\_t i = 0; i $<$ 9; ++i) \{

\noindent         cout $<$$<$ monoms[i] $<$$<$ endl;

\noindent     \}

\noindent     

\noindent     for ( int  i = 10; i $>$= 0; --i)

\noindent         cout $<$$<$ monoms[0] $<$$<$ endl;

\noindent     return 0;

\noindent \}

\noindent int testCountLeadingZeroes() \{

\noindent 

\noindent     GFElementsContainer seq1\eqref{GrindEQ__4_};

\noindent     seq1[0] = gfes[0];

\noindent     seq1[1] = gfes[1];

\noindent     seq1[2] = gfes[2];

\noindent     seq1[3] = gfes[3];

\noindent     

\noindent     BMAlgorithm alg( gf );

\noindent 

\noindent     GFElementsContainer seq2\eqref{GrindEQ__4_};

\noindent     seq2[0] = field\_element(\&gf,1);

\noindent     seq2[1] = gfes[1];

\noindent     seq2[2] = gfes[2];

\noindent     seq2[3] = gfes[3];

\noindent     

\noindent     assert( alg.countLeadingZeroes(seq2) == 0 );

\noindent     

\noindent     seq2[0] = field\_element(\&gf,0);

\noindent     seq2[1] = field\_element(\&gf,0);

\noindent     assert( alg.countLeadingZeroes(seq2) == 2 );

\noindent     

\noindent     seq2[2] = field\_element(\&gf,0);

\noindent     seq2[3] = field\_element(\&gf,0);

\noindent     assert( alg.countLeadingZeroes(seq2) == std::numeric\_limits$<$size\_t$>$::max() );

\noindent     //cout $<$$<$ 

\noindent     

\noindent     return 0;

\noindent \}

\noindent 

\noindent int testPolySeqProduct() \{

\noindent     GFElementsContainer seq1\eqref{GrindEQ__4_};

\noindent     seq1[0] = gfes[0];

\noindent     seq1[1] = gfes[1];

\noindent     seq1[2] = gfes[2];

\noindent     seq1[3] = gfes[3];

\noindent     

\noindent     BMAlgorithm alg( gf );

\noindent     GFElementsContainer prod1 = alg.polySeqProduct( poly1, seq1 );

\noindent     assert( gfes[0]*gfes[1] + gfes[1]*gfes[2] == prod1[1] );

\noindent     

\noindent     // cout $<$$<$ alg(seq1) $<$$<$ endl;   

\noindent     //std::cout $<$$<$ prod1.size() $<$$<$ endl;

\noindent     //copy( prod1.begin(), prod1.end(), std::ostream\_iterator$<$field\_element$>$( std::cout," ") );

\noindent     //std::cout $<$$<$ endl;       

\noindent 

\noindent     // cout $<$$<$ gfes[0]*gfes[1] + gfes[1]*gfes[2] $<$$<$ endl;

\noindent 

\noindent     return 0;

\noindent \}

\noindent 

\noindent int testAlg() \{

\noindent     field\_element gfes[] = \{

\noindent         field\_element(\&gf,3),

\noindent         field\_element(\&gf,1),

\noindent         field\_element(\&gf,0),

\noindent         field\_element(\&gf,5),

\noindent         field\_element(\&gf,4),

\noindent         field\_element(\&gf,7),

\noindent         field\_element(\&gf,2)

\noindent     \};    

\noindent     cout $<$$<$ "GF\eqref{GrindEQ__8_}" $<$$<$ endl $<$$<$ "init sequence:\textbackslash t";

\noindent     for ( size\_t i = 0; i $<$ 7; ++i ) \{

\noindent         cout $<$$<$ gfes[i] $<$$<$ " ";

\noindent     \}

\noindent     cout $<$$<$ endl $<$$<$ endl;

\noindent 

\noindent     field\_polynomial poly( alg( gfes, 7 ) );

\noindent     LFSR lfsr( poly, gfes );    

\noindent     cout $<$$<$ lfsr;

\noindent     cout $<$$<$ "LFSR works:\textbackslash t";

\noindent     for ( size\_t i = 0; i $<$ 20; ++i ) \{

\noindent         cout $<$$<$ lfsr() $<$$<$ " ";

\noindent     \}

\noindent     cout $<$$<$ endl;

\noindent     

\noindent     return 0;

\noindent \}

\noindent 

\noindent class SequenceTester \{

\noindent public:

\noindent     enum FailureReason \{ ENDLESS\_LOOP = 0, NOT\_MATCH = 1 \};

\noindent     

\noindent     SequenceTester( field\& \_gf ) : gf( \_gf ), 

\noindent                                             alg( gf ), 

\noindent                                             failures() \{

\noindent     \}

\noindent     

\noindent     void testSequence( const GFElementsContainer\& initseq ) \{

\noindent         try \{

\noindent             field\_polynomial poly( alg( initseq ) );

\noindent             LFSR lfsr( poly, initseq );

\noindent             GFElementsContainer resultseq;

\noindent             std::generate\_n( std::back\_inserter( resultseq ), initseq.size(), lfsr);

\noindent             if ( initseq != resultseq )

\noindent                 failures.push\_back( std::make\_pair( NOT\_MATCH, initseq ) );

\noindent         \} catch( const std::logic\_error\& ) \{

\noindent             failures.push\_back( std::make\_pair( ENDLESS\_LOOP, initseq ) );

\noindent         \}

\noindent     \}

\noindent     

\noindent     bool hasFailures() \{ return !failures.empty(); \}

\noindent 

\noindent     void printFailures() \{

\noindent         const FailuresContainer::const\_iterator end = failures.end();

\noindent         for ( FailuresContainer::const\_iterator it = failures.begin(); it != end; ++it ) \{

\noindent             cout $<$$<$ std::setw\eqref{GrindEQ__12_} $<$$<$

\noindent                     ( it-$>$first == NOT\_MATCH ) ? "Not match:" : "Endless loop:";

\noindent             copy( it-$>$second.begin(), it-$>$second.end(), 

\noindent                     ostream\_iterator$<$field\_element$>$( cout, " " ) );

\noindent             cout $<$$<$ endl;

\noindent         \}

\noindent     \}

\noindent private:

\noindent     field\& gf;

\noindent     BMAlgorithm alg;

\noindent     typedef std::list$<$ std::pair$<$ FailureReason , GFElementsContainer $>$ $>$ FailuresContainer;

\noindent     FailuresContainer failures;

\noindent \};

\noindent 

\noindent class SequencesGenerator \{

\noindent     field\& gf;

\noindent     const size\_t length;

\noindent     GFElementsContainer currentSequence;

\noindent     SequenceTester\& tester;

\noindent 

\noindent public:

\noindent     SequencesGenerator( field\& \_gf, size\_t \_len, SequenceTester\& \_tester ) : gf( \_gf ), 

\noindent                             length( \_len ), currentSequence( length ), tester( \_tester ) \{\}

\noindent     

\noindent     void operator()() \{

\noindent         sequencesGenerating( 0 );

\noindent         if ( tester.hasFailures() ) \{

\noindent              cout $<$$<$ "There were failures!" $<$$<$ endl;

\noindent         \} else \{

\noindent             cout $<$$<$ "Succeed!" $<$$<$ endl;

\noindent         \}

\noindent     \}

\noindent     

\noindent     void sequencesGenerating( size\_t currentElementToChangeIdx ) \{

\noindent         for ( size\_t i = 0; i $<$= gf.mask(); ++i ) \{

\noindent             currentSequence[ currentElementToChangeIdx ] = field\_element( \&gf, i );

\noindent             if ( currentElementToChangeIdx == length - 1 ) \{

\noindent                 tester.testSequence( currentSequence ); // next sequence to test is ready

\noindent                 // testSequence(); // - just to print

\noindent             \} else \{

\noindent                 sequencesGenerating( currentElementToChangeIdx + 1 );   // recursion!

\noindent             \}

\noindent         \}

\noindent     \}

\noindent     

\noindent     void testSequence() \{   // stub

\noindent         copy( currentSequence.begin(), currentSequence.end(), 

\noindent                 ostream\_iterator$<$field\_element$>$( cout, " " ) );

\noindent         cout $<$$<$ endl;

\noindent     \}

\noindent private:

\noindent     void operator=( const SequencesGenerator\& );

\noindent \};

\noindent 

\noindent int totalSequencesTesting() \{

\noindent     SequenceTester tester( gf );

\noindent     SequencesGenerator generator( gf, 5, tester );

\noindent     generator();

\noindent     return 0;

\noindent \}

\noindent 

\noindent 

\noindent int testLongSequence() \{

\noindent     //field gf(primitive\_polynomial\_size14 - 1, primitive\_polynomial\_size14 - 1, 

\noindent     //        primitive\_polynomial14); // 17

\noindent     //field gf( primitive\_polynomial\_size11 - 1, primitive\_polynomial\_size11 - 1, 

\noindent     //        primitive\_polynomial11); // 13

\noindent     const size\_t len = 100;

\noindent     const size\_t fieldSize = gf.mask() + 1;

\noindent     GFElementsContainer seq;

\noindent     for( size\_t i = 0; i $<$ len; ++i )

\noindent         seq.push\_back( field\_element( \&gf, rand()\%fieldSize ) );

\noindent     // printSequence( seq );

\noindent     SequenceTester tester( gf );

\noindent     tester.testSequence( seq );

\noindent     if ( tester.hasFailures() ) \{

\noindent          cout $<$$<$ "There were failures!" $<$$<$ endl;

\noindent     \} else \{

\noindent         cout $<$$<$ "Succeed!" $<$$<$ endl;

\noindent     \}

\noindent     // std::system("pause");   

\noindent     

\noindent     return 0;

\noindent \}

\noindent 

\noindent void printSequence( const GFElementsContainer\& seq, 

\noindent         std::ostream \&out ) \{

\noindent     copy( seq.begin(), seq.end(), 

\noindent             ostream\_iterator$<$field\_element$>$( out, " " ) );

\noindent     out $<$$<$ endl;

\noindent \}

\noindent 


\end{document}

% == UNREGISTERED! == GrindEQ Word-to-LaTeX 2008 ==

