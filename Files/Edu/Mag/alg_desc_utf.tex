\documentclass[14pt]{extarticle}
\usepackage{cmap}
\usepackage[utf8x]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english, russian]{babel}
\usepackage{ucs}
\usepackage[pdftex,unicode,linkcolor=blue,draft=false,  %backref=page,
    bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
    colorlinks=true]{hyperref}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{url}
\usepackage{listings}
\usepackage{setspace}

\onehalfspacing

\lstset{language=[ISO]C++,basicstyle=\small,%\ttfamily,
breaklines=true,showstringspaces=false}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,calc}

\usepackage{geometry}
\geometry{left=3cm}
\geometry{right=2cm}
\geometry{top=2cm}
\geometry{bottom=2cm}

\usepackage{alg_desc}

\newtheorem{note}{Замечание}

\title{BMS-алгоритм и его применение в декодере}
\author{магистрант кафедры алгебры и дискретной математики\\Пеленицын~А.~М.}
\date{}

\begin{document}

\setcounter{page}{2}
\tableofcontents

\section*{Введение}
\addcontentsline{toc}{section}{Введение}
 
Теория помехоустойчивого кодирования является активно развивающейся областью
науки и техники второй половины двадцатого, начала двадцать первого века. Её
задача была определена Клодом Шенноном в 1948 году в статье «Математическая
теория связи»~\cite{Shannon63ru}, где были сформулированы основные составляющие
модели передачи данных по каналу с шумом. Алгебраическая теория кодирования,
сформировавшаяся в 60–70-е гг.,
решает задачу борьбы с помехами в канале алгебраическими методами. К 80-м годам
двадцатого века были открыты многочисленные классы помехоустойчивых кодов,
некоторые из которых нашли широкое применение в практике; из последних стоит
отметить коды Рида–Соломона. В то же время теория кодирования пережила,
наверное, самый большой переворот за свою историю связанный с применением
алгебро-геометрических методов в конструировании кодов.

Первым заметившим, что аппарат алгебраической геометрии можно использовать для
создания классов кодов с хорошими (не достигавшимися ранее) параметрами, был
Гоппа~\cite{Goppa77}. Стоит также отметить фундаментальную работу в этом
направлении российских учёных Влэдуца и Цфасмана~\cite{Tsfasman82} 1982 года. С
конца 80-х и на протяжении 90-х количество работ, посвященных этим вопросам,
только возрастало. Упомянем серию публикаций группы датских учёных по
конструированию и декодированию одного класса сравнительно простых с точки
зрения использовавшихся фактов алгебраической геометрии
кодов~\cite{Justesen89}~\cite{Justesen92}~\cite{Sakata95}. Надо признать, что в
2000-е центр внимания профессионального сообщества сместился в сторону
списочного декодирования.

С наступлением «алгебро-геометрической эры» в кодировании стал вопрос о том,
какие из классических подходов могут быть применены в новых условиях. Оказалось,
что к таковым относится конструкция кодов Рида—Соломона и общий метод их
декодирования, включая такой конструктивный элемент последнего как алгоритм
Берлекэмпа—Месси (BM\nbdash алгоритм). BM-алгоритм с момента своего появления в 1968
году получил широкое распространение не только для декодирования разнообразных
классов кодов теории помехоусточивого кодирования, но и в других областях
прикладной (например, криптография~\cite{Alferov05}) и фундаментальной
(например, теория аппроксимаций Паде~\cite{Gashkov04}) математики.

Обобщение BM-алгоритма для декодирования алгебро-\nspace геометрических кодов
связано с увеличением размерности задачи. Такое обобщение предложил
Саката~\cite{Sakata88}, после чего алгоритм стал именоваться алгоритмом
Берлекэмпа—Месси—Сакаты (BMS-алгоритмом). Он был применён для декодирования
семейства кодов из~\cite{Justesen89}, кроме того были разработаны более общие
коды, для декодирования которых также может быть использован
BMS-ал\-го\-ритм~\cite{OSullivan01}.

Одной из проблем в области помехоустойчивого кодирования, основанного на фактах
алгебраической геометрии, является сложность реализации рассматриваемых
конструкций сравнительно с классическими (реализации как программной,
так и, в особенности, аппаратной).

Целью данной работы стала реализация BMS-алгоритма и изложение подхода к его
применению в декодировании АГ\nobreakdash-кодов. Для достижения этой цели были
поставлены задачи:
\begin{itemize}
	\item изучение BMS-алгоритма, его связи с BM-алгоритмом и возможностей его
	реализации;
	\item разработка схемы BMS-алгоритма, которая может служить практическим
	руководством к реализации;
	\item реализация BMS-алгоритма с использованием разработанной схемы;
	\item изучение АГ-кодов типа кодов Рида\emd Соломона и метода их 
	декодирования~\cite{Justesen89}~\cite{Justesen92}~\cite{Sakata95};
	\item создание схемы декодера АГ-кодов типа кодов Рида\emd Соломона.
\end{itemize}

Результаты работы докладывались на конференции «Неделя науки» ЮФУ и X
Международной научно-практической конференции «Информационная безопасность» в г.
Таганроге, тезисы опубликованы в соответствующих
сборниках~\cite{Pelenitsyn08a}~\cite{Pelenitsyn08b}. Часть результатов 
опубликована в издании, входящем в список ВАК~\cite{Pelenitsyn08c}.

Работа состоит из введения, трёх глав и приложения, содержащего исходные коды
выполненной реализации BMS-алгоритма.

\section{BMS-алгоритм}

\subsection{BM-алгоритм}
\label{BMalg}

%Задачи реш алг БМ, их применение в помехоуст код (и
%криптографии)-подробно, следующее --- декларативно

%Появление двумерных последовательностей ...

%Задачи реш будующий алг  БМС

%Саката

Первоначальная версия алгоритма Берлекэмпа—Месси (BM-\nspace алгоритма) была
изложена Берлекэмпом в 1968 году~\cite{Berlekamp68} в качестве элемента
конструкции декодера кодов Боуза—Чоудхудри—Хоквингема над конечным полем. Хотя в
этой работе была указана возможность формулировки решаемой задачи с
использованием понятия линейного регистра сдвига с обратной связью, алгоритм
описывался исключительно в терминах полиномов и был весьма сложен для понимания.
Спустя год Месси~\cite{Massey69} предложил свою интерпретацию алгоритма, который
теперь строил линейный регистр сдвига минимальной длины, генерирующий заданную
последовательность элементов конечного поля. Эта интерпретация оказалась
полезной для более широкого распространения алгоритма, получившего название по
имени этих двух ученых.

С момента появления алгоритма вышло немало работ, развивающих, обобщающих и
по-новому интерпретирующих его идеи (например,
\cite{Gashkov04} \cite{Kurakin99} \cite{Sakata89}). Рассматриваемый алгоритм
находит применение при декодировании различных классов кодов: кодов
Рида—Соломона, кодов БЧХ, циклических и обобщенных циклических кодов,
альтернантных кодов и кодов Гоппы, и, наконец, наиболее общего и актуального на
сегодня класса кодов — алгебро-геометрических кодов (вернее, некоторых их
подклассов).

Построим структурную схему BM-алгоритма, следуя его описанию в~\cite{Kurakin94}.

\emph{Последовательностью} над полем $\field$ будем называть любую функцию $u:
\mathbb N_{0} \to \field$, заданную на множестве целых неотрицательных чисел и принимающую значения в этом поле. 

Элементы последовательности $u$ будут обозначаться $u(i)$. Будет встречаться также понятие \emph{отрезка последовательности}, которое получается естественным образом из ограничения функции, упомянутой в определении. 

Последовательность $u$ будем называть \emph{линейной рекуррентной последовательностью }(ЛРП) \emph{порядка $m>0$ над полем }$\field$, если существуют константы $f_{0} ,\; ...\; ,f_{m-1} \in \field$ такие, что
\[u(i+m)=\sum _{j=0}^{m-1}f_{j} \cdot u(i+j) , i\ge 0.\]
Указанное выражение назовем \emph{законом рекурсии} или \emph{линейным рекуррентным соотношением}. Говорят, что $\{f_j\}_{j=0}^{m-1}$ задают закон рекурсии для 
ЛРП~$u$.

Как видно, первые $m$ элементов последовательности не связаны какими-либо ограничениями — они имеют особое значение, их, как правило, 
называют \emph{начальным отрезком} последовательности $u$.

Пусть $u$ — ЛРП, для  которой $\{f_j\}_{j=0}^{m-1}$ задают закон рекурсии. 
Многочлен:
\[F(x)=x^{m} -\sum _{j=0}^{m-1}f_{j} \cdot x^{j}  \]
с коэффициентами из поля $\field$ назовем \emph{характеристическим многочленом} 
ЛРП $u$.

Таким образом, каждой ЛРП можно поставить в соответствие характеристический многочлен и обратно, каждому нормированному многочлену можно поставить в соответствие ЛРП. Можно показать однако, что одна и та же последовательность может задаваться \emph{разными} законами рекурсии и, соответственно, иметь разные характеристические полиномы.

Характеристический полином ЛРП $u$, имеющий наименьшую степень, назовем её \emph{минимальным многочленом}, а его степень — \emph{линейной сложностью} ЛРП $u$.

Минимальные многочлены ЛРП, а также их линейная сложность, являются важными характеристиками ЛРП. 

Пусть $u$ — последовательность над полем $\field$. Обозначим через
$$u\left(\overline{0,l-1}\right)=(u(0),\ldots ,u(l-1))$$
начальный отрезок $u$. Будем говорить, что многочлен
\[G(x)=x^{m} -\sum _{j=0}^{m-1}b_{j} \cdot x^{j}\] 
\emph{вырабатывает отрезок} $u\left(\overline{0,l-1}\right)$, если
\[\forall i\in [0,l-m-1]:\; u(i+m)=\sum _{j=0}^{m-1}b_{j} \cdot u(i+j),\] 
то есть если данный отрезок последовательности является отрезком некоторой ЛРП с характеристическим многочленом $G(x)$.

 Естественным образом определяется понятие линейной сложности отрезка последовательности как минимальной степени из всех полиномов, вырабатывающих данный отрезок.

Алгоритм Берлекэмпа—Месси строит многочлен $G(x)$ наименьшей степени, вырабатывающий отрезок $u\left(\overline{0,l-1}\right)$. Чтобы перейти к непосредственному описанию алгоритма, требуется ввести ещё ряд вспомогательных определений.

Введём операцию умножения произвольного многочлена
$$H(x)=\sum _{j=0}^{n}h_{j} x^{j}$$
на любую последовательность $v$, результатом которой будет последовательность 
$w$, такая что:
\[(H(x)\cdot v)(i)=w(i)\eqdef\sum _{j=0}^{n}h_{j} \cdot v(i+j) \] 

Очевидно, операция является линейной относительно полинома, входящего в неё.

Для нормированного полинома $G(x)$ определим параметры: 
\begin{enumerate}
\item  $k_{u} (G)$ — количество лидирующих нулей последовательности $G(x)\cdot u$ или $\infty$, если эта последовательность нулевая.

\item  $l_{u} (G)=k_{u} (G)+\deg (G)$.
\end{enumerate}

Легко убедиться, что $l_{u} (G)$ — максимальная длина начального отрезка $u$, вырабатываемого $G(x)$. Действительно, пусть
\[G(x)=\sum _{j=0}^{m}g_{j} \cdot x^{j} = x^{m} -\sum _{j=0}^{m-1}b_{j} \cdot x^{j}. \] 
Обозначим $G(x)\cdot u=v$. Тогда: 
$$\forall i\in [0,l_{u} (G)-m-1]:\;v(i)=0,$$
но:
\[0=v(i)=\sum _{j=0}^{n}g_{j} \cdot u(i+j)=u(i+m)-\sum _{j=0}^{m-1}b_{j} \cdot u(i+j),\] 
что и дает искомое:
$$\forall i\in [0,l_{u} (G)-m-1]:u(i+m)=\sum _{j=0}^{m-1}b_{j} \cdot u(i+j).$$ 

Теперь можно привести полную схему классического BM-ал\-го\-рит\-ма. Зададимся
последовательностью $u$ над полем $\field$ и числом $l$. Найдем минимальный
полином $G(x)$, вырабатывающий отрезок $u\left(\overline{0,l-1}\right)$,
используя BM-алгортим, описываемый нижеследующей структурной схемой, построенной
по работе~\cite{Kurakin94}.

%\begin{center}\end{center}
%\subsection*{Схема BM-алгоритма}
\newpage
\tikzstyle{decision} = [diamond, draw]
\tikzstyle{block} = [rectangle, draw, text centered]
\tikzstyle{block_2lines} = [block, text width=9cm]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{cloud} = [draw, ellipse]
\begin{tikzpicture}[node distance = 2cm, auto, inner sep=3pt]
    % Place nodes
	\node [cloud] (start) {Вход: $u$, $l$};
	\node [block, below of=start, node distance=1.5cm] (init) {$G_0(x):=1$, $l_0:=l_u(G_0)$};
	\node [decision, below of=init] (init_len_comp) {$l_0 < l$};
	\node [block_2lines, below of=init_len_comp, yshift=-.5cm] (G1)
		{$G_1(x) := x^{k_0 + 1} - u_0(k_0+1)u_0(k_0)^{-1}G_0(x)$,\\$l_1 {:=} l_u(G_1)$, $t{:=}1$};
	\node [decision, below of=G1, yshift=-.3cm] (len_comp) {$l_t < l$};
	\node [block_2lines, below of=len_comp, yshift=-.3cm] (determ_s) 
		{определим $s$ из соотношения:\\$m_t=m_{t-1}=\ldots=m_{s+1}>m_s$};
    % Draw edges
    \node [decision, below of=determ_s, yshift=-.5cm] (k_comp)
    	{$k_t > k_s$};
    \node [block, below of=k_comp, xshift=-1.7cm, yshift=-.3cm] (k_comp_yes)
    	{$G_{t+1}(x) := x^{k_t - k_s}G_t(x) - u_t(k_t)u_s(k_s)^{-1}G_s(x)$};
	\node [block, below of=k_comp, xshift=1.7cm, , yshift=-.3cm, node distance=3.5cm] (k_comp_no)
		{$G_{t+1}(x) := G_t(x) - x^{k_t - k_s}u_t(k_t)u_s(k_s)^{-1}G_s(x)$};
	\node [block, below of=k_comp, yshift=-.3cm, node distance=5cm] (renew_l_t)
		{$l_{t+1} := l_u(G_{t+1})$, $t:=t+1$};
	\node [block, right=of renew_l_t, xshift=1.3cm, yshift=-1cm] (answer) {$G(x):=G_t(x)$};
	\node [cloud, below of=answer] (exit) {Выход: $G(x)$};
	
	%Place edges
    \path [line] (start)	 	-- (init);
    \path [line] (init)  	 	-- (init_len_comp);
    \path [line] (init_len_comp)-- node {Да} (G1);
    \path [line] (G1)  		 	-- (len_comp);
    \path [line] (len_comp)	 	-- node {Да} (determ_s);
    \path [line] (determ_s)  	-- (k_comp);
    \path [line] (answer)  		-- (exit);
    \path [line] (init_len_comp)-| node [near start] {Нет} (answer);
    \path [line] (len_comp) 	-| node [near start] {Нет} (answer);
    \path [line] (k_comp.west)  -| node [near start] {Да} 
    	($ (k_comp_yes.north west) + (2cm,0) $);
    \path [line] (k_comp.east)  -| node [near start] {Нет} 
    	($ (k_comp_no.north east) - (2cm,0) $);
    \path [line] ($ (k_comp_yes.south west) + (2cm,0) $)  |- (renew_l_t);
    \path [line] ($ (k_comp_no.south east) - (2cm,0) $)   |- (renew_l_t);
    \path [line] (renew_l_t.south) -- ++(0, -1cm) -- ++ (-7cm, 0) |- (len_comp.west);
\end{tikzpicture}

\subsection{Предварительные обозначения и конструкции для BMS-\nspace алгоритма}
\label{Prelim}
\renewcommand{\labelitemi}{}
\renewcommand{\labelitemii}{}

Введём обозначения для следующих множеств: $\NO=\{0,1,2,\ldots\}$,
$\qplane=\NO^2$. Элементы $\qplane$ будем называть точками и
выделять полужирным шрифтом, например: $\pt n \in \qplane$.
Компоненты точек будем обозначать нижними индексами, например,
компоненты точки $\pt n$: $n_1, n_2$. Для точек $\qplane$ определено
покомпонентное сложение:
$$\forall \pt n, \pt m\in\qplane: \pt n + \pt m\eqdef(n_1 + m_1, n_2 + m_2).$$
Аналогично будем использовать вычитание точек, когда оно корректно
(обе координаты уменьшаемого не меньше соответствующих координат вычитаемого).

Сумма точки и множества точек определяется так:
$$\forall s\in\qplane\:\forall M\subset\qplane:\; s+M\eqdef\{s+m\mid m\in M\}.$$

Введём два отношения порядка на $\qplane$:
\begin{enumerate}
   \item $\forall \pt m, \pt n \in \qplane:\; \pt m < \pt n$ тогда и только
      тогда, когда
      $$(m_1 \leq n_1) \wedge (m_2 \leq n_2) \wedge (\pt m \neq \pt n);$$
   \item $\forall \pt m, \pt n \in \qplane:\;
      \pt m \ltot \pt n$ тогда и только
      тогда, когда
      \begin{equation}\label{TotalOrd}
        \bigr(m_1 + m_2  <  n_1 + n_2\bigr)\;
         \vee\;\bigl((m_1 + m_2  =  n_1 + n_2)\wedge(m_2 < n_2)\bigr).
      \end{equation}
\end{enumerate}
Первое отношение является отношением частичного порядка, а второе — отношением
линейного порядка. Естественным образом определяются рефлексивные версии этих
отношений («нестрогие неравенства»): $\leq,\letot$. Будут использоваться также
обозначения $\pt m \not< \pt n$ и ${\pt m\not\leq\pt n}$, когда выполнено одно
из неравенств $m_1 >n_1$ или $m_2 >n_2$, или оба сразу.

Линейный  порядок позволяет для каждой точки $\pt n$ единственным образом
определить {\em непосредственно следующую за ней\/} точку $\pt {n'}$ :
$$\forall \pt n \in \qplane:\;\pt {n'}
   = \left\{ \begin{array}{lc}
      (n_1-1,n_2+1), & \text{ если } n_1>0,\\
      (n_2+1,0), & \text{ если } n_1=0.
   \end{array} \right.
$$

Введём  множества:
%\begin{itemize} \item
\begin{eqnarray*}
   \forall \pt m \in \qplane:& &\Sigma_{\pt m}
      \eqdef\{\pt p \in \qplane\mid\pt m \le \pt p\};\\
   \forall \pt m, \pt n \in \qplane:& &\Sigma_{\pt m}^{\pt n}
      \eqdef\{\pt p \in \qplane\mid(\pt m \le \pt p)\,\wedge\,(\pt p\ltot \pt
      n)\}.
\end{eqnarray*}
%\end{itemize}
Отметим, что если $\pt n \letot \pt m$, то множество $\Sigma_{\pt m}^{\pt n}$
пусто. Кроме того, обратим особое внимание, что
   $\pt n \not \in \Sigma_{\pt m}^{\pt n}$.

Пусть задано поле Галуа $\field$. Полином от двух переменных над полем $\field$,
т.~е. элемент кольца ${\field[x]\eqdef\field[x_1,x_2]}$, будем записывать так:
$$f(x)=\sum_{\pt m \in \Gamma_f}f_{\pt m}\cdot x^{\pt m},$$
где $x^{\pt m}={x_1^{m_1}\cdot x_2^{m_2}}$, $f_{\pt m} \in \field$, а
конечное множество $$\Gamma_f=\{\pt m \in\qplane\mid f_{\pt m}\ne0\}$$ ---
носитель множества коэффициентов. Линейный порядок на $\qplane$ позволяет
корректно определить (\emph{старшую}) \emph{степень} полинома $f$, которую будем
обозначать $\LP(f)$:
$$ \forall f \in \field[x]:\;\LP(f)\eqdef\max_{\pt m \in \Gamma_f}\pt m, $$
где максимум берется в смысле линейного порядка на $\qplane$. Для
произвольного (упорядоченного) набора полиномов
$\mathcal{F}=\{f^{(i)}(x)\}_{i=1}^l$ определим:
$$ \LP(\mathcal F) \eqdef \{\pt s^{(i)} = \LP(f^{(i)})\}_{i=1}^l $$

{\em Конечной двумерной последовательностью\/} (или просто {\em
последовательностью\/}) $u$ «длины» $\pt p \in \qplane$ над полем
$\field$ назовем отображение $$u:\qplane^{\pt p}\to\field.$$
Ограничение этого отображения на множество $\qplane^{\pt n}$ для
некоторого $\pt n \in\qplane^{\pt p'}$ обозначим $u^{\pt n}$ и
назовем {\em$\pt n$\nbdash срезкой $u$}. Отметим, что $\pt n$\nbdash
срезка $u$ в свою очередь является двумерной последовательностью
длины $\pt n$.

Для полинома $f$ степени $\pt s$, последовательности $u$ длины $\pt p$ и точки
$\pt n\in\Sigma_{\pt s}^{\pt p}$ определим элемент поля $\field$:
\begin{equation}\label{polyseqprod}
   f[u]_{\pt n}\eqdef
      \sum_{\pt m \in \Gamma_f}f_{\pt m}\cdot u_{\pt m + \pt n - \pt s}.
\end{equation}
Напомним, что в случае $\pt p\letot \pt s$ множество $\Sigma_{\pt
s}^{\pt p}$ пусто. Будем писать $f \in \VP(u)$ тогда и только тогда,
когда
\begin{equation}\label{Conv}
   \forall\pt n\in\Sigma_{\pt s}^{\pt p}:\,f[u]_{\pt n}=0.
\end{equation}
Таким образом, в случае $\pt p \letot \pt s$ условие $f \in \VP(u)$ выполнено
тривиально.
%либо для либо $\pt p \letot \pt s$.
%либо = 0, либо не имеет смысла

Очевидно, для любой последовательности $u$ длины $p$ выполнено:
$$\forall \pt m, \pt n \in \qplane^{\pt p'}:\: m \ltot n \Rightarrow
   \VP(u^{\pt m}) \supset \VP(u^{\pt n})$$
Уточним этот факт для случая последовательно идущих точек:
\begin{multline*}\label{RemainsInValpol}
   \forall \pt n \in \qplane^{\pt p} \: \forall f \in \VP(u^{\pt
   n}):\\
      f \in \VP(u^{\pt n'}) \Leftrightarrow
      \bigl(\pt n \not\in \Sigma_{\LP(f)}^{\pt n'}\bigr)
         \vee \bigl(f[u]_{\pt n}=0\bigr).
\end{multline*}
Действительно, $\forall \pt s, \pt n \in\qplane:\;\Sigma_{\pt s}^{\pt
n'}\setminus
\Sigma_{\pt s}^{\pt n}\subset\{\pt n\}$. Таким образом, надо рассмотреть два
случая:
\begin{enumerate}
   \item $\Sigma_{\LP(f)}^{\pt n'}\setminus\Sigma_{\LP(f)}^{\pt n}=\emptyset$,
      т.~е. $\Sigma_{\LP(f)}^{\pt n'}=\Sigma_{\LP(f)}^{\pt n}$, тогда по
      определению
      $$f \in\VP(u^{\pt n}) \Rightarrow f \in\VP(u^{\pt n'}).$$

   \item $\Sigma_{\LP(f)}^{\pt n'}\setminus\Sigma_{\LP(f)}^{\pt n}=\{\pt n\}$,
      тогда
      \begin{multline}
      f\in\VP(u^{\pt n'}) \Leftrightarrow\\
      \forall m\in \Sigma_{LP(f)}^{\pt n'}=\Sigma_{LP(f)}^{\pt n}\cup\{\pt n\}:
      \; f[u]_{\pt m}=0
      \Leftrightarrow\\f\in\VP(u^{\pt n}) \wedge f[u]_{\pt n}=0.
      \end{multline}
\end{enumerate}

%не нужно проверять никаких новых условий вида~(\ref{Conv}),

Назовём набор точек $\{\pt s^{(i)}\}_{i=1}^l$ {\em набором гиперболического
типа} (или просто {\em гиперболическим набором\/}), если для него выполнены
соотношения:
\begin{equation}\label{DeltaProp}
s_1^{(1)}>s_1^{(2)}>\ldots>s_1^{(l)}=0,\;0=s_2^{(1)}<s_2^{(2)}<\ldots<s_2^{(l)}.
\end{equation}
Каждому гиперболическому набору точек $\{\pt s^{(i)}\}_{i=1}^l$ поставим в
соответствие множество $\Delta=\Delta(\{\pt s^{(i)}\}_{i=1}^l)$, определяемое по
формуле:
$$\Delta(\{\pt s^{(i)}\}_{i=1}^l)=\qplane\setminus(\Sigma_{\pt
s^{(1)}}\cup\Sigma_{\pt s^{(2)}}\cup\ldots\cup\Sigma_{\pt s^{(1)}}),
$$Множество $\Delta=\Delta(\{\pt s^{(i)}\}_{i=1}^l)$ в этом случае назовем
{\em$\Delta$\nbdash множеством} для набора $\{\pt s^{(i)}\}_{i=1}^l$. В свою
очередь набор $\{\pt s^{(i)}\}_{i=1}^l$ называется {\em определяющими точками}
$\Delta$.

Если для некоторого упорядоченного набора полиномов
$$\mathcal{F}=\{f^{(i)}(x)\}_{i=1}^l$$ их степени $$\LP(\mathcal F) =
\{\pt s^{(i)}\}_{i=1}^l$$ составляют гиперболический набор, то
$\Delta(\LP(\mathcal F))$ мы будем обозначать просто
$\Delta(\mathcal{F})$.

Пусть дана конечная двумерная последовательность $u$ «длины» $\pt
p$. {\em Минимальным множеством} (полиномов) для последовательности
$u$ называется набор $\mathcal{F}=\{f^{(i)}(x)\}_{i=1}^l$,
удовлетворяющий условиям:
\begin{enumerate}
   \item $\mathcal{F}\subset\VP(u).$
   \item $\LP(\mathcal{F})$ --- гиперболический набор.
   \item $\forall g\in\field[x]:
      \;g\in\VP(u)\Rightarrow\LP(g)\notin\Delta(\mathcal{F})$.
\end{enumerate}

Условие (3) гарантирует единственность гиперболического набора,
задаваемого любым минимальным множеством для данной
последовательности. Если $\mathcal F$ — некоторое минимальное
множество  для последовательности $u$, то $\Delta(\mathcal F)$ можно
обозначить $\Delta(u)$. Существование минимального множества для
последовательности будет доказано конструктивно — описанием
алгоритма, строящего его.
% Минимальное множество существует (... теоремы 1 и 2...).
% ...гиперболический набор определяется однозначно по определению...


\subsection{Схема BMS-алгоритма}\label{BMS}

Данный алгоритм, разработанный Сакатой в \cite{Sakata88} на основе
модификации классического алгоритма Берлекэмпа--Месси, строит
минимальное множество полиномов $F$ для произвольной
последовательности $u$ «длины» $\pt p$. Перед тем как описать шаги
алгоритма, нужно ввести некоторые множества, с которыми работает
алгоритм, и дополнительные обозначения.

Алгоритм имеет итеративный характер: на каждой итерации значение параметра $\pt
n\in\qplane$ («мультиномер итерации») заменяется на точку, непосредственно
следующую за $\pt n$. Как только $\pt n$ станет равным $\pt p$ (длине
последовательности), алгоритм завершится.

К началу $\pt n$-ой итерации
сформированы:
%: множество $F$ будет минимальным множеством для $u$

\begin{itemize}
   \item$F=\{f^{(i)}(x)\}_{i=1}^l$ — минимальное множество для $\pt n$\nbdash
   срезки $u$;
   \item$G=\{g^{(i)}(x)\}_{i=1}^{l-1}$ — вспомогательное множество
   полиномов, такое что:
   $$\forall i\in [1,l-1]\; \exists \pt p^{(i)} \in \qplane^{\pt n}:
   g^{(i)}\in\VP(u^{\pt p^{(i)}})\setminus\VP(u^{{\pt p^{(i)}}'}),$$
   в частности,  $d^{(i)}\eqdef g^{(i)}[u]_{\pt p^{(i)}}\neq0$. Более точно:
   $g^{(i)}$ входил в $F$ на итерации $\pt p^{(i)}$, но не мог входить в него
   при переходе к $\pt p^{(i)'}$ из-за того, что $d^{(i)}\neq0$.

   С $F$ связано множество:
   \begin{itemize}
      \item$S=\{\pt s^{(i)}\}_{i=1}^l=\LP(F),$
   \end{itemize}
   с $G$ связаны три множества:
   \begin{itemize}\item$T=\{\pt t^{(i)}\}_{i=1}^{l-1} = \LP(G)$,
      \item$PG=\{\pt p^{(i)}\}_{i=1}^{l-1}$,
      \item$DG=\{d^{(i)}\}_{i=1}^{l-1}$.
   \end{itemize}
\end{itemize}

Введём следующие обозначения, которые используют перечисленные
параметры алгоритма и, таким образом, зависят от мультиномера
текущей итерации $\pt n$:
\begin{enumerate}
   \renewcommand{\labelenumi}{(\theenumi)}
   \item Опишем число $\inSD{\pt s}\in [0, l-1]_{\N_0}$ для любого $\pt
s\in \qplane$:
   \begin{itemize}
      \item если $\pt n \not \in \pt s+\Delta(F)$, положим $\inSD{\pt s}
         \eqdef 0$,
   %введём следующее множество:
      %$$\pt s+\Delta\eqdef\{\pt s + \pt m\,|\,\pt m \in \Delta\},$$
      \item если $\pt n \in \pt s+\Delta(F)$, то $\exists i \in [1,l-1]_{\NO}$,
         такой что:
         $$ (n_1 < s_1 + s_1^{(i)}) \wedge (n_2 < s_2 + s_2^{(i+1)}),$$
         любой из таких $i$ обозначим $\inSD{\pt s}$.
   \end{itemize}

   \begin{note}
      inSD — «in shifted Delta-set», «в сдвинутом дельта-множестве»:
      мультиномер $\pt n$ текущей итерации находится в сдвинутом
      на $\pt s$ $\Delta$\nbdashмножестве.
   \end{note}

   \item $\forall i\in[1,l]_\N, j\in [0,l-1]_{\NO}$:
      $$\\\BP{i}{j}\eqdef\left\{ \begin{array}{l}
         \text{$f^{(i)}$, $j=0$;}\\
         \text{$x^{\pt r - \pt s^{(i)}} \cdot f^{(i)} - (d/d^{(j)}) x^{\pt r
            - \pt n + \pt p^{(j)} - \pt t^{(j)}} \cdot g^{(j)}$, иначе,}
      \end{array} \right.$$
      где $d = f^{(i)}[u]_{\pt n}$, $r_k=\max\{s_k^{(i)};
      t_k^{(j)} + n_k - p_k^{(j)}\},\,k \in\{1,2\}$;

   \item $\forall i\in[1,l]_\N\;\forall k \in\{1,2\}$:$$\SP{k}{i}\eqdef
      x_k^{n_k-s_k^{(i)}+1} \cdot f^{(i)};$$
\end{enumerate}

%Вместо $\Delta(F)$ будем иногда писать $\Delta$.

\noindent\textbf{Вход}: двумерная последовательность $u$ длины $\pt
p$ над полем $\field$.

\noindent\textbf{Выход}: минимальное множество $F$ для $u$.


\begin{enumerate}\setcounter{enumi}{-1}
\renewcommand{\theenumi}{\arabic{enumi}}
\renewcommand{\theenumii}{\arabic{enumii}}
\renewcommand{\labelenumi}{\textbf{Шаг \theenumi.}}
\renewcommand{\labelenumii}{(\theenumii)}
   \item\label{init} Положить $\pt n := (0,0)$, $F:=\{1\}\:
	  (\Delta(F)=\emptyset)$, $G:=DG:=PG:=\emptyset$.

   \begin{note}
      Инициализация параметров алгоритма совпадает с~\cite[п.~5,
      шаг~1]{Sakata88}.
   \end{note}


   \item\label{buildFVandFN} $\forall i \in [1, l]_\N$:
      $$\aif \; \pt s^{(i)} \not\leq \pt n \; \vee f^{(i)}[u]_{\pt n}=0\;
      \athen f^{(i)} \in F_V\; \aelse f^{(i)} \in F_N.$$

   \begin{note}
      Множества $F_V, F_N \subset F$ вводятся в~\cite{Sakata88} после
      теоремы~1, п.~4.
      $F_V$ — множество полиномов, которые не требуют изменения на текущей
      итерации (V — valid, эффективный, действительный). $F_N$ — множество
      полиномов, которые необходимо модифицировать на данной итерации (N —
      nonvalid).
   \end{note}

   \begin{note}
      Условие $\pt s^{(i)} \not\leq \pt n$ влечёт за собой $\pt n \not\in
      \Sigma_{\pt s^{(i)}}^{\pt n'}$. Как указано в~(\ref{RemainsInValpol}),
      этот факт вместе с имеющимся к началу $\pt n$\nbdashой итерации
      $f^{(i)} \in \VP(u^{\pt n})$
      влечет за собой
      $f^{(i)} \in \VP(u^{\pt n'})$.
      Этот случай не обсуждается в~\cite{Sakata88}.
   \end{note}

   \item\label{BuildAux}
      Введём $aux := \overline 0_l$ — вектор из $l$ компонент, пока нулевой.
      $$\forall f^{(i)}\in F_N: aux[i]:=\inSD {\pt s^{(i)}},$$
      где $aux[i]$ — $i$-ая компонента вектора $aux$.

   \item\label{T1case}
      $\aif\; \forall f^{(i)} \in F_N:\; aux[i]\neq0\; \athen$
         $$\quad \forall f^{(i)} \in F_N:\; f^{(i)}:=\BP{i}{aux[i]};\;
         \goto \text{Шаг~\ref{IterEnd}.}$$

   \begin{note}
      Условие шага~\ref{T1case} взято непосредственно из описания
      алгоритма~\cite[п.~5, шаг~2]{Sakata88}. Отличие состоит в использовании
      вспомогательного вектора $aux$, хранящего сразу все результаты
      проверок $\pt n \in \LP(f^{(i)}) + \Delta$ (выполняемых в этом месте
      в~\cite{Sakata88}) и использовании нашего обозначения $\inSD n s$
      (шаг~\ref{BuildAux}) для этих проверок.
   \end{note}

   \begin{note}\label{Theor1ApplyingNote}
      Формула для пересчёта $f^{(i)}$ вытекает из теоремы~1
      в~\cite[п.~4]{Sakata88}, а верней, её обоснования,
      приведенного перед формулировкой. Использование теоремы~1
      продиктовано~\cite[п.~5, шаг~2]{Sakata88}.
   \end{note}


   \item\label{buildDeltaSet} Построить следующие множества точек:
      %\begin{itemize}
         %\item
         \begin{multline*}\shoveright{\Delta_1 = \{(s_1^{(i)},s_2^{(i)}) \mid
            i\in[1,l]_\N \wedge \left(f^{(i)}\in F_V \vee aux[i]\neq0\right)\};}
         \end{multline*}
         %\item
         \begin{multline*}\Delta_2 =
            \{(n_1 - s_1^{(i)} + 1, n_2 - s_2^{(i+1)} + 1) \mid
            i\in[1,l-1]_\N \wedge \\f^{(i)},f^{(i+1)}\in F_N\};
         \end{multline*}
         %\item
         \begin{multline*}\Delta_3 = \{(n_1 - s_1^{(i)} + 1,s_2^{(j)}) \mid
            i,j\in[1,l]_\N\wedge \\(f^{(i)},f^{(j)}\in F_N) \wedge
            (\pt s^{(i)} + \pt s^{(j)} \leq \pt n)
            \wedge\\ (\forall k \in (i,l]_\N: n_2 < s_2^{(k)} +s_2^{(j)})\};
         \end{multline*}
         %\item
         \begin{multline*}\Delta_4 = \{(s_1^{(i)}, n_2 - s_2^{(j)} + 1) \mid
            i,j\in[1,l]_\N\wedge \\(f^{(i)},f^{(j)}\in F_N)\wedge
            (\pt s^{(i)} + \pt s^{(j)} \leq \pt n) \wedge\\
            \forall k \in [1,j)_\N: n_1 < s_1^{(k)} + s_1^{(i)}\}.
         \end{multline*}
      $\Deltanew =
         \Delta_1 \cup \Delta_2 \cup \Delta_3 \cup \Delta_4$.
      %\end{itemize}

   \begin{note}\label{NewDeltaNote}
      Необходимость построения нового $\Delta$-\nspace множества (а в след за ним и
      нового $F$ — см. следующий шаг) указывается
      в~\cite[п.~5, шаг~2]{Sakata88} со ссылкой на теорему ~2. В теореме~2
      описывается построение нового $F$ по $\Delta_e(u^{\pt n'})$ —
      множеству «исключённых точек». Последнее составляют точки, которые
      обладают таким свойством: $\lnot \exists f \in \VP(u^{\pt n'}): \LP(f)
      \in \Delta_e(u^{\pt n'})$. Фактически на нашем шаге 4 строится $\Delta_e(
      u^{\pt n'} )$, но так как теорема~2 указывает способ построения полиномов,
      старшие степени которых являются определяющими точками $\Delta_e(u^{\pt
      n'})$, то $\Delta_e(u^{\pt n'}) = \Delta(u^{\pt n'})$.
   \end{note}

   \begin{note}
      Множество $\Delta_e(u^{\pt n})$ определяется в \cite[стр.~327]{Sakata88},
      основываясь на лемме 4. По построению видно, что $\Delta_e(u^{\pt n})$
      это $\Delta$-множество. %\ref{NewDeltaNote}
   \end{note}

   \begin{note}
      Условия включения точек каждого из четырех типов описаны
      в~\cite{Sakata88}: Леммы 8 и 9 и предшествующие им
      рассуждения (после теоремы~1). Сами четыре типа перечислены в
      Лемме~7~\cite{Sakata88}.
   \end{note}
   
   \begin{note}
   		В соответствии с определением $\Delta$-множества (см.~(\ref{DeltaProp})),
   		при построении $\Delta_3$ и $\Delta_4$ можно рассматривать лишь $k=i+1$ 
   		и $k=j-1$ соответственно. Эта оптимизация не указана в~\cite{Sakata88}.
   \end{note}
   
   \begin{note}
   		Информация об элементах $\Delta_r$ включает не только точку $\qplane$, 
   		но и «историю появления» этой точки, то есть числа $i$, $j$.
   \end{note}
   
   \item\label{buildFNew} Построить следующие множества полиномов.\\
      %\begin{enumerate}
         %\item
         \multlinegap=0pt
         $F_1 = \{\BP i {aux[i]} \mid (s_1^{(i)},s_2^{(i)}) \in \Delta_1\};$
         \begin{multline*}F_2 = \{\BP k i \mid
            (n_1 - s_1^{(i)} + 1, n_2 - s_2^{(i+1)} + 1) \in
            \Delta_2,\\k: f^{(k)}\in F_N \;\wedge\; \pt s^{(k)} < \pt t\};
         \end{multline*}
         \begin{multline*}F_3 = \{\BP j i \mid
            (n_1 - s_1^{(i)} + 1,s_2^{(j)}) \in \Delta_3 \wedge i \neq l \}\;
            \cup\\
            \{\SP 1 j \mid (n_1 + 1,s_2^{(j)}) \in \Delta_3\}
         \end{multline*}
         \begin{multline*}F_4 = \{\BP i {j-1} \mid
            (s_1^{(i)}, n_2 - s_2^{(j)} + 1) \in \Delta_4 \wedge j \neq 1 \}\;
            \cup\\
            \{\SP 2 i \mid (s_1^{(i)}, n_2 + 1) \in \Delta_4\}
         \end{multline*}
         
         $\Fnew = F_1 \cup F_2 \cup F_3 \cup F_4$.
         
   \begin{note}
      Построение $\Fnew$ с точностью до обозначений и группировки случаев~C и~D,
	  а также~E и~F (для рассмотрения, соответственно, точек типа~(3) и~(4)),
	  следует теореме~2~\cite{Sakata88}.
   \end{note}
   
   \begin{note}
      Точки типа~(1), согласно рассуждениям, следующим за
      теоремой~1~\cite{Sakata88}, появляются в случаях если полином, который
      обеспечил её вхождение в $\Deltanew$ (назовём его $f^{(i)}$) либо лежит в
      $F_V$ либо может быть переведён в $\VP(u^{(n')})$ с помощью
      теоремы~1~\cite{Sakata88}. В первом случае соответствующая компонента
      векотра $aux$ равна 0 (по построению) и формула $\BP i {aux[i]}=
      \BP i 0 =f^{(i)}$ оставит полином неизменным, во втором случае эта формула
      в точности реализует теорему~1~\cite{Sakata88}.
   \end{note}

   \begin{note}
      Существование $k$ из построения полинома для точек типа~(2) упоминается
      непосредственно в теореме~2~\cite{Sakata88} со ссылкой на доказательство
      леммы 8.
   \end{note}

   \item\label{buildGNew}Построить $\Gnew$, исходя из условий:
      $\Gnew \subset G \cup F_N$ и
      $|\Gnew|=|\Fnew|-1$. Пронумеровать элементы $\Gnew$, следуя следующему
      правилу. Каждый полином $g \in \Gnew$ получает номер $i \in [1,l-1]_\N$,
      если выполнено условие:
      \begin{equation}\label{IndexingG}
         s_k^{(i+k-1)}=r_k - t_k + 1,
      \end{equation}
      где $k\in \{1,2\}$, $\pt t = \LP(g)$ и
      \begin{equation}
         \pt r = \left\{\begin{array}{ll}
                     \pt p^{(i)} \in PG, & \text{если $g \in G$;}\\
                     \pt n,              & \text{если $g \in F_N$.}
                  \end{array}\right.
      \end{equation}

   \begin{note}
      Условие $\Gnew \subset G \cup F_N$ указано в~\cite[п.~5, шаг~2]{Sakata88}.
      Условие $|\Gnew|=|\Fnew|-1$ взято из определения $G$.
      Формула~(\ref{IndexingG}) взята из~\cite[(12)]{Sakata88}, с учетом, что
      для $g\in F_N$ (элементов $G$, добавившихся на текущей итерации) в роли
      $\pt p^{(i)}$ выступает мультиномер текущей итерации — $\pt n$.
   \end{note}

   \item\label{NewAuxSetsAndReplacing}
      Построить множества $\Tnew$, $\PGnew$, $\DGnew$ для $\Gnew$, следуя
      описанию $T$, $PG$ и $DG$. Поясним способ построения $\PGnew$: если
      $g^{(i)}$ из $\Gnew$ принадлежит $G$, то его параметр $\pt p^{(i)}$
      просто берется из $PG$, в противном случае, если он принадлежит $F_N$,
      то его параметр $\pt p^{(i)}$ полагается равным $\pt n$.
      
      Заменить $F, G, T, PG, DG$ на $\Fnew, \Gnew, \Tnew, \PGnew, \DGnew$.

   \item\label{IterEnd} $\pt n := \pt {n'}$; 
      $$\aif\:\pt n=\pt p\quad
         \athen\text{exit;}\quad
         \aelse\goto\text{Шаг~\ref{buildFVandFN}.}$$
   \begin{note}
      Условие окончания или продолжения алгоритма совпадает с
      указанным в~\cite[п.~5, шаг~3]{Sakata88}.
   \end{note}
\end{enumerate}

\subsection{Пример выполнения BMS-алгоритма}

%Для удобства будем обозначать элементы некоторой последовательности $u$ не 
%$u_\pt n$, а $u(n_1,n_2)$. 
Рассмотрим следующую последовательность $u: \qplane^{\pt (5,1)} \to \mathbb
F_2=\{0,1\}$~\cite{Sakata88}:
$$\begin{matrix}
u_{(0,0)}=0, & u_{(0,1)}=1, & u_{(0,2)}=0,\\
u_{(1,0)}=1, & u_{(1,1)}=1,\\
u_{(2,0)}=0,\\
u_{(3,0)}=0.
\end{matrix}$$
% & u_{(0,3)}=1, & u_{(0,4)}=0, \\
% & u_{(1,2)}=0, & u_{(1,3)}=0,\\
% & u_{(2,1)}=1, & u_{(2,2)}=0,\\
%, & u_{(3,1)}=0\\
%u_{(4,0)}=0,\\
%u_{(5,0)}=0.\\
Применим к ней BMS-алгоритм, используя схему, построенную в предыдущем разделе.
Назовём «итерацией алгоритма» один проход по
шагам~\ref{buildFVandFN}–\ref{IterEnd} и будем нумеровать итерации римскими
цифрами. Номера шагов в соответствии со схемой будут обозначаться арабскими
цифрами.

Некоторые шаги данной итерации, на которых делать
ничего не потребуется, будем пропускать, не оговаривая это каждый раз особо. Например, если после шага~\ref{buildFVandFN} $F_N=\emptyset$, то надо сразу переходить на шаг~\ref{IterEnd} (по goto из шага~\ref{T1case}).

Пусть заданы начальные значения из шага~\ref{init}: $\pt n := (0,0)$, 
$F:=\{f^{(1)}=1\}$, $(\Delta(F)=\emptyset)$, $G:=DG:=PG:=\emptyset$.
\begin{enumerate}
\renewcommand{\theenumi}{\Roman{enumi}}
\renewcommand{\theenumii}{\arabic{enumii}}
		\item
		Шаг~\ref{buildFVandFN}. $\pt s^{(1)}=(0,0) \leq \pt n = (0,0).$\\
		$f^{(1)}[u]_{(0,0)} = f_{(0,0)}u_{(0,0)} = 1\cdot0=0 \Longrightarrow
		f^{(1)}\in F_V$. $F_N=\emptyset$.
		
		Условие шага~\ref{T1case} выполнено тривиально ($F_N=\emptyset$). 
		Перейдём на шаг~\ref{IterEnd}.
		
		Шаг~\ref{IterEnd}. $\pt n := (0,1)$.
		
		\item
		Шаг~\ref{buildFVandFN}. $\pt s^(1) = (0,0) \leq \pt n = (1,0)$\\
		$f^{(1)}[u]_{(1,0)} = f_{(0,0)}u_{(1,0)} = 1 \Longrightarrow
		f^{(1)}\in F_N.$
		
		Шаг~\ref{BuildAux} Вычислим $aux[1]$: 
			$$ \Delta = \emptyset \Rightarrow \pt n \not \in \LP(f^{(1)}) 
			+ \Delta (= \emptyset) \Rightarrow \inSD {\pt s^{(1)}} = 0 
			\Rightarrow aux[1] = 0.$$
			
		Условие шага~\ref{T1case} не выполнено. Переходим на 
		шаг~\ref{buildDeltaSet}.
		
		Шаг~\ref{buildDeltaSet}. $\Delta_1=\Delta_2=\emptyset$, $\Delta_3=\{ 
		(1,0)\}$ ($i=j=1$), $\Delta_3=\{(1,0)\}$ ($i=j=1$).
		
		Шаг~\ref{buildFNew}. $F_3=\{x_1^{n_1 - s_1^{(1)} +1}f^{(1)}=x_1^2\}$, 
		$F_4=\{x_2^{n_2 - s_2^{(1)} +1}f^{(1)}=x_2\}$.
		
		Шаг~\ref{buildGNew}. $\Gnew = {g^{(1)}=1}$.
		
		Шаг~\ref{NewAuxSetsAndReplacing}. $\PGnew=\{\pt p^{(1)} = (1,0)\}$, $\DGnew 
		= \{d^{(1)}=1\}$. $F=\{f^{(1)} = x_1^2; f^{(2)} = x_2\}$, 
		$\Delta=\{(0,0); (1,0)\}$.
		
		Шаг~\ref{IterEnd}. $\pt n :=(0,1)$.
		
		\item
		Шаг~\ref{buildFVandFN}. $\pt s^{(1)} = (2,0) \not\leq \pt n=(0,1)
		\Longrightarrow f^{(1)}\in F_V$.\\
		$\pt s^{(2)}=(0,1) \leq \pt n = (0,1)$.\\
		$f^{(2)}[u]_{(0,1)} = f_{(0,1)}u_{(0,1)} = 1\cdot 1=1 \Longrightarrow 
		f^{(2)}\in F_N$.
		
		Шаг~\ref{BuildAux}. $\pt n=(0,1) \in \pt s^{(2)} + \Delta = \{(0,1); 
		(1,1)\} \Longrightarrow aux[2] = 1$.
		
		Шаг~\ref{T1case}. Условие выполнено. $f^{(2)} := \BP 2 1 = x_2 + x_1$.
		
		Шаг~\ref{IterEnd}. $\pt n := (2,0)$ ($F = \{f^{(1)} = x_1^2; f^{(2)} 
		= x_2  + x_1\}$).
		
		\item
		Шаг~\ref{buildFVandFN}. $\pt s^{(1)}=(2,0) \leq \pt n = (2,0)$.\\
		$f^{(1)}[u]_{(2,0)} = f_{(2,0)}u_{(2,0)} = 1\cdot 0=0 \Longrightarrow 
		f^{(2)}\in F_V$.\\
		$\pt s^{(2)} = (0,1) \not\leq \pt n=(2,0)
		\Longrightarrow f^{(2)}\in F_V$.
		
		Шаг~\ref{IterEnd}. $\pt n := (1,1)$.
		
		\item
		Шаг~\ref{buildFVandFN}.
		$\pt s^{(1)} = (2,0) \not\leq \pt n=(1,1)
		\Longrightarrow f^{(1)}\in F_V$.\\
		$\pt s^{(2)} = (0,1) \leq \pt n = (1,1)$.
		\begin{multline*}
		f^{(2)}[u]^{(1,1)} = \sum f_{\pt m} u_{\pt m + (1,0)} = f_{(1,0)}
		u_{(2,0)} + f_{(0,1)}u_{(1,1)} = \\ = 0 + 1 =1 \Longrightarrow 
		f^{(2)}\in F_N.
		\end{multline*}
		
		Шаг~\ref{BuildAux}. $\pt n = (1,1) \in \pt s^{(2)} + \Delta = \{(0,1);
		(1,1)\}$, $aux[2] = 1$.
		
		Шаг~\ref{T1case}. Условие выполнено. $f^{(2)} \coleq \BP 2 1 = x_2 + 
		x_ 1 + 1$. Переход на шаг~\ref{IterEnd}.
		
		Шаг~\ref{IterEnd}. $pt n \coleq (0,2)$ ($F = \{f^{(1)} = x_1^2; f^{(2)}
		= x_2  + x_1 + 1\}$).
		
		\item
		Шаг~\ref{buildFVandFN}. $\pt s^{(1)} = (2,0) \not\leq \pt n = (0,2)
		\Longrightarrow f^{(1)}\in F_V$.\\
		$\pt s^{(2)} = (0,1) \leq \pt n = (0,2)$.
		\begin{multline*}
			f^{(2)}[u]_{(0,2)} = \sum f_{\pt m}u_{\pt m + (0,1)} = \\
			= f_{(0,0)} u_{(0,1)} + f_{(1,0)} u_{(1,1)} + f_{(0,1)} u_{(0,2)}=\\
			= 1 + 1 + 0 = 0 \Longrightarrow f^{(2)}\in F_V.
		\end{multline*}
		
		Шаг~\ref{IterEnd}. $\pt n \coleq (3,0)$.
		
		\item
		Шаг~\ref{buildFVandFN}. $\pt s^{(1)} = (2,0) \leq \pt n = (3,0)$.\\
		$f^{(1)}[u]_{(3,0)} = \sum f_{\pt m} u_{\pt m + (1,0)} = f_{(2,0)}
		u_{(3,0)} = 0 \Longrightarrow f^{(1)} \in F_V$.\\
		$\pt s^{(2)}=(0,1) \not\leq \pt n=(3,0)\Longrightarrow f^{(2)} \in F_V$.
		
		Шаг~\ref{IterEnd}. $\pt n \coleq (2,1)$.
		
%		\item
%		Шаг~\ref{buildFVandFN}. $\pt s^{(1)} = (2,0) \leq \pt n = (2,1)$.\\
%		$f^{(1)}[u]_{(2,1)} = \sum f_{\pt m} u_{\pt m + (0,1)} = f_{(2,0)}
%		u_{(2,1)} = 1 \Longrightarrow f^{(1)} \in F_N$.\\
%		$\pt s^{(2)} = (0,1) \leq \pt n = (2,1)$.
%		\begin{multline*}
%			f^{(2)}[u]_{(2,1)} = \sum f_{\pt m} u_{\pt m + (2,0)} =  \\
%			= f_{(0,0)} u_{(2,0)} + f_{(1,0)} u_{(3,0)} + f_{(0,1)} u_{(2,1)}=\\
%			= 0 + 0 + 1 = 0 \Longrightarrow f^{(2)}\in F_N.
%		\end{multline*}
%		
%		Шаг~\ref{BuildAux}. $\pt n = (2,1) \not\in \pt s^{(1)} + \Delta = 
%		\{(2,0); (3,0)\} \Longrightarrow aux[1] = 0$.\\
%		$\pt n = (2,1) \not\in \pt s^{(2)} + \Delta = 
%		\{(0,1); (1,1)\} \Longrightarrow aux[2] = 0$.
%		
%		Шаг~\ref{T1case}.  Условие не выполнено, переходим на 
%		шаг~\ref{buildDeltaSet}.
%		
%		Шаг~\ref{buildDeltaSet}. $\Delta_1 = \emptyset$.
%		
%		$\Delta_2$: для $i=1$: $f^{(1)}, f^{(2)} \in F_N$, значит $(n_1 - 
%		s_1^{(i)} + 1, n_2 - s_2^{(i+1)} + 1) = (1,1)\text{---}i=1 \in
%		\Delta_2$. Других таких $i$ нет, значит $\Delta_2 = 
%		\{(1,1)\text{---}i=1\}$.
%		
%		$\Delta_3:$
%		\begin{itemize}
%			\item $i=j=1$: $\pt s^{(1)} + \pt s^{(1)} = (4,0) \not\leq 
%				\pt n = (2,1)$.
%			\item $i=1, j=2$: $\pt s^{(1)} + \pt s^{(2)} = (2,1) \leq 
%				\pt n = (2,1)$; $k\coleq i+1=2$, ${n_2=1}<{s_2^{(2)} + 
%				s_2^{(2)} = 1 + 1 = 2} \Rightarrow (n_1 - s_1^{(1)} + 1,
%				s_2^{(2)}) = (1,1)\text{---}i=1,j=2 \in \Delta_3$.
%			\item $i=2, j=1$: $\pt s^{(2)} + \pt s^{(1)} = (2,1) \leq 
%				\pt n = (2,1) \Rightarrow (n_1 - s_1^{(2)} + 1,
%				s_2^{(1)}) = (3,0)\text{---}i=2,j=1 \in \Delta_3$.
%			\item $i=j=2$: $\pt s^{(2)} + \pt s^{(2)} = (0,2) \not\leq 
%				\pt n = (2,1)$.
%		\end{itemize}
%		
%		$\Delta_4:$ Случаи $i=j=1$, $i=j=2$ аналогично не дают новых точек.
%		\begin{itemize}
%			\item $i=1, j=2$: $\pt s^{(1)} + \pt s^{(2)} = (2,1) \leq 
%				\pt n = (2,1)$; $k\coleq j-1=1$, ${n_1=2}<{s_1^{(1)} + 
%				s_1^{(1)} = 2 + 2 = 4} \Rightarrow (s_1^{(1)}, 
%				n_2 - s_2^{(j)} + 1) = (2,1)\text{---}i=1,j=2 \in \Delta_3$.
%			\item $i=2, j=1$: $\pt s^{(2)} + \pt s^{(1)} = (2,1) \leq 
%				\pt n = (2,1) \Rightarrow (s_1^{(2)}, 
%				n_2 - s_2^{(1)} + 1) = (0,2)\text{---}i=2,j=1 \in \Delta_3$.		\end{enumerate}
%
%		\item
%		Шаг~\ref{buildFVandFN}.
%		
%		\item
%		Шаг~\ref{buildFVandFN}.
%		
%		\item
%		Шаг~\ref{buildFVandFN}.
%		
%		\item
%		Шаг~\ref{buildFVandFN}.
		
\end{enumerate}
%====================================================================


\section{Реализация}

Реализация алгоритма выполнена с использованием языка программирования общего
назначения C++ в соответствии с действующим стандартом~\cite{CppStand}, и в
совокупности с широким распространением компиляторов с этого языка может
использоваться на большом числе программно\nbdash аппаратных платформ. Подготовлены
бинарные сборки для платформы x86-GNU/Linux (бинарный формат ELF).

При реализации использованы две библиотеки программных кодов с открытыми
исходными кодами:
\renewcommand{\labelitemi}{\textbullet}
\begin{itemize}
    \item NTL, версия 5.4.2~\cite{NTL} —
    содержит реализацию арифметики в конечных полях;
    \item Boost, версия 1.37.0~\cite{Boost} — использованы средства, повышающие
    удобство использования STL.
    %, как например, \texttt{bind} (предназначен для всключения в
    %будущий стандарт языка C++~\cite[20.7.12]{Cpp0x}).
\end{itemize}
Кроме того, NTL может быть опционально скомпилирована с библиотекой GMP (GNU
Multiple Precision Arithmetic Library~\cite{GMP}) для повышения
производительности, что и было сделано в данном случае (версия GMP 4.2.2).
Использованные в работе библиотеки либо проверены временем — разработка NTL
относится к началу 90-х и с тех пор стабильно поддерживается, — либо имеют
мощное сообщество пользователей и разработчиков, куда входят, в частности,
профессионалы, ответственные за развитие языка C++ (Boost).

Реализация спроектирована в объектно-ориентированном стиле с широким применением
STL, которая вносит элементы аппликативного программирования. Работу по
реализации можно разделить на три части:
\renewcommand{\theenumii}{\arabic{enumii}}
\renewcommand{\labelenumi}{\theenumi.}
\begin{enumerate}
    \item Арифметический процессор: полиномы от двух переменных, двумерные
    последовательности, точки дискретной плоcкости (с учётом дифференциации
    точек, накладываемой алгоритмом).
    \item Определение контейнерных структур данных для представления
    совокупностей полиномов, которыми в разных контекстах оперирует алгоритм.
    \item Реализация алгоритма.
\end{enumerate}
Ниже охарактеризованы основные особенности каждой из этих подсистем.

\subsection{Арифметический процессор}
\label{Arithmetics}

Стоит отметить, что NTL содержит реализацию арифметики в кольцах полиномов лишь
от одной переменной; самостоятельных библиотек с открытой реализацией
полиномов двух (многих) переменных аналогичного NTL и Boost класса найти не
удалось. Был создан класс полиномов от двух переменных, а также реализованы
необходимые операции с объектами этого класса.

Реализация последовательно использует механизм шаблонов C++. В первую очередь
это относится к параметризации типов коэффициентов полинома и элементов
последовательности. Такое решение обусловлено
несколькими причинами. Одна из них — дизайн NTL, в которой конечные поля
различных типов (простые, расширенные, характеристики $2$)
представлены совокупностью не связанных между собой какими-либо языковыми
средствами классов. В такой ситуации обеспечение полиморфизма создаваемого кода
не может осуществляться при помощи традиционных для
объектно-ори\-ен\-ти\-ро\-ван\-но\-го программирования механизмов наследования и
виртуальных
функций. С другой стороны, шаблоны хорошо показывают себя при работе с
набором классов, реализующих некоторый «неявный интерфейс» (случай NTL),
обеспечивая параметрический полиморфизм~\cite{C++Templates}.

Удобство использования шаблонов C++ совместно с классами NTL
отчасти может быть обусловлено тем, что библиотека во многих моментах
полагается на механизм
макросов (это остаётся, однако, практически не заметным для её пользователя):
шаблоны создавались, в том числе, как замена небезопасным в использовании
макросам и, решая аналогичные задачи, шаблоны — быть может, против воли
создателей — достаточно хорошо сочетаются с макросами.

Вторая причина попытки создать код, абстрагированный от типов конкретных
алгебраических структур, состоит в том, что исходный алгоритм Берлекэмпа—Месси
находит всё новые интерпретация, расширения и обобщения. В том числе,
рассматривались варианты алгоритма над различными типами колец и
модулями~\cite{Kurakin94,Kurakin99}, кроме того, в более поздних, чем
основная~\cite{Sakata88} для данной реализации, работах
Сакаты изучалась задача построения группы полиномов с предписанными нулями
в предположении, что нули лежат в некотором расширении поля коэффициентов
многочленов~\cite{Sakata89}. В этой ситуации одной из задач стало создание
максимально гибкой реализации основных модулей программы для облегчения
дальнейшего изучения алгоритма и его приложений.

Как и в случае классического
алгоритма Берлекэмпа—Месси, в расчётах не используется умножение двух полиномов
общего вида, а~— только умножение полинома на моном, что делает разумным
отдельную реализацию этой операции, которая работает более эффективно, чем
умножение в общем случае.

Из других особенностей реализации подсистемы арифметического процессора можно
указать решение, связанное с операцией $f[u]_{\pt n}$. Здесь использован
паттерн проектирования, известный под именем Прокси-класс (или
Заместитель)~\cite{GoF}. Одной из задач реализации была удобочитаемость кода,
в обеспечении которой большую роль играет перегрузка операций C++. В данном
случае была перегружена операция обращения по индексу (subscript operator) класса
полинома. Однако, эта операция не может быть сделана тернарной (что позволило бы
легко приблизить её вызов к математической записи). В таких случаях можно
воспользоваться дополнительным классом (обычно его называют прокси-класс),
который сохраняет информацию, переданную бинарной операции обращения по индексу,
то есть «запоминает» ссылки на полином и последовательность, и для которого
определена перегруженная операция вызова функции (call operator), принимающая
объект-точку дискретной плоскости. Последняя выполняет необходимые вычисления, а
в коде это выглядит так: \texttt{f[u](n)}. Важным является тот факт, что
прокси-класс является деталью реализации, которая остаётся максимально скрытой
для клиента класса полинома.

\subsection{Контейнерные структуры данных}
\label{Containers}

В ходе выполнения алгоритма конструируются и изменяются ряд множеств. Было
выделено три типа данных:
\begin{itemize}
    \item \texttt{PolySet} для хранения текущего минимального множества.
    \item \texttt{PolyWithAuxInfo} для хранения «вспомогательного» (auxiliary)
    множества $G$.
    \item \texttt{PolySubset} для хранения подмножеств минимального множества
    $F_V$ и $F_N$.
\end{itemize}
Первые два основаны на стандартном типе множества C++ \texttt{std::set} и
определяют несколько дополнительных операций, используемых в алгоритме. Выбор
\texttt{std::set} обусловлен необходимостью поддерживать указанные множества в
порядке, таком что старшие степени образуют гиперболический набор: здесь
используется особенность типа множества C++, которое в действительности является
\emph{упорядоченным} множеством. Пример добавленной операций доставляет
добавленная в \texttt{PolySet} проверка того, что данная точка находится в
сдвинутом в данную точку $\Delta$-множестве, определяемом данным минимальным
множеством полиномов (т.~е. объектом \texttt{PolySet}). Кроме того, в обоих
типах присутствует операция обращения по индексу для того, чтобы код, реализующий
процедуру Берлекэмпа, наиболее выразительно отражал математическую запись.

\texttt{PolyWithAuxInfo} является множеством, хранящим тройки: полином, точка
дискретной плоскости и элемент поля (упакованные в структуру C++), — сочетая в
себе, таким образом, три множества из описания алгоритма: $G$, $PG$, $DG$.
Множества старших степеней для $F$ и $G$, то есть $S$ и $T$, также не хранятся
отдельно: степень является полем класса полинома, и потому информация из $S$ и
$T$ содержится в объектах \texttt{PolySet} и \texttt{PolyWithAuxInfo}
соответственно.

Третий контейнерный тип \texttt{PolySubset} реализован как стандартный список
(\texttt{std::list}) структур, содержащих пары: итератор, указывающий на полином в
текущем минимальном множестве, и индекс этого полинома. Таким образом, для
хранения полиномов в подмножествах исключено дополнительное копирование. Это
можно считать вариантом паттерна Приспособленец (Flyweight)~\cite{GoF}. Здесь
сыграли роль не только соображения эффективности, но и особенности алгоритма:
рассматривая полином в подмножестве нужно иметь возможность модифицировать его
либо удалять — так, чтобы эти изменения отразились на самом минимальном
множестве.

Стоит отметить, что простое (отдельно стоящее) определение псевдонима типа
(\texttt{typedef}) списка структур для случая \texttt{PolySubset} выполнить
нельзя, потому что тип итератора по множеству полиномов зависит от шаблонных
параметров полинома, тогда возможное определение псевдонима было бы шаблонным,
что запрещено текущим стандартом C++. Эта сложность известная под названием
template typedefs будет снята в следующем стандарте C++, где определения
«шаблонных псевдонимов» будут разрешены~\cite{Cpp0x}.

\subsection{Реализация алгоритма}
Весь алгоритм был оформлен в виде отдельного класса. Объектно\nbdash ориентированный
подход к построению реализации алгоритма позволил произвести достаточно глубокую
декомпозицию, чтобы отразить основные шаги алгоритма. Были выделены основные
фазы алгоритма, код выполнения которых помещался в отдельные методы. Определены,
во-первых, данные, используемые и последовательно изменяемые несколькими фазами,
а значит, подлежавшие оформлению в виде полей класса, и, во-вторых, данные,
являющиеся локальными для каждого шага или даже его части. Таким образом,
принятые в ходе проектирования решения помогают глубже понять природу и
особенности алгоритма. 

Известно, что объектно-ориентированный подход позволяет последовательно строить
сколько угодно сложные абстракции, равномерно распределяя общую сложность между
различными уровнями абстракции. Два описанных выше программных модуля содержали
более низкоуровневые объекты и операции. Реализация же самого алгоритма в
сравнении с ними представляется более высокоуровневой. Поясним этот тезис. 

Класс алгоритма \texttt{Algorithm} содержит единственный публичный метод
\texttt{computeMinimalSet} для получения минимального множества по заданной в
конструкторе последовательности, и приведённая в разделе~\ref{BMS} схема
алгоритма практически дословно отображается на тело цикла этого метода:
\begin{lstlisting}[basicstyle=\small,texcl]
buildFNandFV();   // шаг~\ref{buildFVandFN}
if (FN.empty()) { // goto на шаге~\ref{T1case}
    continue;
}
// в условии ниже: шаг~\ref{BuildAux} и if из шага~\ref{T1case}
// параметр degreeInvariantSuppliers — множество aux
if (isAtTheDegreeInvariantPoint(degreeInvariantSuppliers)) {
    renewF(degreeInvariantSuppliers); // then из шага~\ref{T1case}
} else {
    buildNewDeltaSet();               // шаг~\ref{buildDeltaSet}
    PolySet<T,S> F_new = buildNewF(); // шаг~\ref{buildFNew}
    buildNewG(F_new);                 // шаг~\ref{buildGNew}
    F = F_new;
}
\end{lstlisting}
Таким образом, за самым верхним уровнем абстракции, когда мы просто получаем
решение (клиентский код, вызывающий \texttt{computeMinimalSet}), сразу идёт
уровень, решающий задачу в терминах схемы алгоритма (тело
\texttt{computeMinimalSet}). Далее, как видно из приведённого кода, сложность
распределена по методам класса \texttt{Algorithm}. Общее количество этих методов
около пятнадцати штук, но основные из них уже видны выше. Большая часть этих
методов имеет довольно лаконичное тело, так как они, в свою очередь, полагаются
на более низкие уровни абстракции, описанные, в том числе, в
разделах~\ref{Arithmetics} и~\ref{Containers}. 

Исходные коды реализации приведены 
в приложении.

\section{Применение BMS-алгоритма для декодирования 
АГ-кодов типа кодов Ри\-да\emd Со\-ло\-мо\-на}
%[Применение BMS-алгоритма для декодирования АГ-кодов 
%типа кодов Рида—Соломона]
\subsection{АГ-коды типа кодов Рида\emd Соломона}

%В ... АГ-коды типа кодов Рида—Соломона ...

Рассмотрим конструкцию семейства кодов~\cite{Justesen92}, которые иногда
называют ал\-геб\-ро-геометрическими кодами типа кодов Ри\-да—Со\-ло\-мо\-на.
Пусть задано конечное поле $\field$ из $q$ элементов, полином
$C(x,y)\in\field[x,y]$. Множество точек $(x,y)$, координаты $x$ и $y$ которых
лежат в алгебраическом замыкании $\acfield$ поля $\field$, таких что $C(x,y)=0$
называется \emph{афинной кривой}, а сами точки — точками афинной кривой
$C(x,y)$. Точка афинной кривой называется рациональной, если обе её координаты
принадлежат $\field$. 

Для удобства расчёта параметров строящегося семейства кодов на кривую
накладывают дополнительные ограничения. \emph{Полной степенью полинома} $f$ от
любого конечного числа $s$ переменных $\{x_i\}_{i=1}^s$ назовём максимальную
сумму степеней переменных в терме (члене) $f$: 
$$ f = \sum_{\alpha \in \mathbb N_0^s} f_\alpha x^\alpha:\: 
\deg f \eqdef \max_{f_\alpha \neq 0} \sum_i \alpha_i.$$
Определение корректно, так как лишь конечное число $f_\alpha$ отличны от нуля.

Для полинома $f\in\field[x_1, \ldots, x_s]$ определим операцию 
\emph{гомогенизации}~\cite{Cox00} 
$f \mapsto f^h$, $f^h\in\field[x_0, \ldots,x_s]$: 
$$ f^h(x_0, x_1, \ldots, x_s) \eqdef x_0^{\deg f}f\left(\frac {x_1} {x_0}, \ldots, 
\frac {x_s} {x_0} \right). $$
Таким образом, число переменных полинома увеличивается на одну, и он становится
\emph{однородным}, то есть суммарные степени переменных в каждом терме совпадают
(и равны $\deg f$).
 
Важное свойство однородных полиномов состоит в том, что для любого корня
$P\in\field^s$ однородного полинома, $\lambda P$, где $\lambda\in\field$, также
является его корнем. Далее, говоря о корне однородного полинома, будет
подразумеваться корень с точностью до множителя $\lambda$.

Можно определить вложение $\acfield^s \hookrightarrow \acfield^{s+1}$, при
котором все корни исходного полинома $f$ станут корнями $f^h$ (нужно положить
новую координату равной $1$, оставив неизменными старые). Конечно, у $f^h$ могут
появиться и другие корни. Используя геометрический язык, говорят, что кривая
$f^h$ является \emph{проективным замыканием} кривой $f$~\cite{Cox00}.

Определим \emph{формальную частную производную} полинома $f \in \field[x_1,
\ldots, x_s]$ по переменной $x_i$: 
$f \mapsto f_{x_i}$, $f_{x_i}\in \field[x_1, \ldots, x_s]$,
$$ f = \sum_{\alpha \in \mathbb N_0^s} f_\alpha x^\alpha: \: 
	f_{x_i} \eqdef \sum_{\substack{f_\alpha \neq 0\\ \alpha_i > 0}} 
	\alpha_i f_\alpha x^{\alpha - e_i},$$
где запись $\alpha_i f_\alpha$ означает $\sum_{k=1}^{\alpha_i}f_\alpha$, а 
вектор $e_i\in\mathbb N_0^s$ имеет все нулевые координаты, за исключением $i$-ой,
которая равна $1$.

Точка $P$ кривой $f$ называется \emph{особой} (\emph{сингулярной}), если все
формальные частные производные в ней равны нулю. В противном случае точка
называется \emph{неособой} (\emph{гладкой}). Кривая называется
\emph{регулярной}, если её проективное замыкание не имеет особых точек.

Ограничение, о котором упоминалось выше, состоит в том, что для построения
рассматриваемого семейства кодов используются регулярные кривые $C(x, y)$.

Будем считать, что на парах целых неотрицательных чисел $\qplane=\NO^2$ (а
значит, на множестве мономов из $\field[x,y]$) введён линейный порядок $\ltot$
(см.~раздел~\ref{Prelim}). Пусть $C(x,y)=0$ — уравнение регулярной кривой
степени $m$ (то есть старшая относительно $\ltot$ степень многочлена $C(x,y)$
равна $m$), а $\{P_i=(x_i,y_i)\}_{i=1}^n$ — рациональные точки на ней. Выберем
целое $j$, такое, что $$m-2 \leq j \leq \left\lfloor \frac{n-1}{m}
\right\rfloor.$$

Мономы из множества $\{x^a y^b \mid (a,b) \letot (0,j)\}$ перенумеруем так:
$\{\varphi_i\}_{i=0}^\mu$, где $\mu=\mu(j)$ --- более точно, эта нумерация 
определяется биективным отображением
\begin{equation}\label{CantorsNumb}
	(a,b) \mapsto ((a+b)^2 + a + 3b)/2.
\end{equation}

Код типа Рида—Соломона $C^*(j)$ задаётся проверочной матрицей $\mathbf H$:
\begin{equation} \mathbf H =
    \begin{bmatrix}
        \varphi_0(P_1)  & \ldots    & \varphi_0(P_n)\\
        \varphi_1(P_1)  & \ldots    & \varphi_1(P_n)\\
        \vdots          &           & \vdots\\
        \varphi_\mu(P_1)& \ldots    & \varphi_\mu(P_n)
    \end{bmatrix}
\end{equation}
Пусть $k$ это размерность данного кода, а $d_{min}$ — его минимальное
расстояние. Можно доказать~\cite{Justesen89}, что:
$$ k = n - (mj - g + 1),$$
$$ d_{min} \geq d^* = mj - 2g + 2,$$
где $g$ это параметр, называемый \emph{родом кривой}. В случае регулярной кривой
степени $m$ $$g=(m-1)(m-2)/2.$$ Величина $d^*$ называется \emph{конструктивным
кодовым расстоянием}.

\subsection{Метод декодирования АГ-кодов типа кодов Рида\emd Соломона Юс\-те\-се\-на\emd Лар\-се\-на\emd Йен\-се\-на\emd Хо\-холь\-да}
\label{DecodingMethod}

Ниже будет изложен метод декодирования, первоначально описанный в~\cite{Justesen92}.

Пусть по каналу пришло слово $\mathbf r\in\field^n$, и $\mathbf{r = c + e}$, где
$\mathbf c$ это кодовое слово, а $\mathbf e$ — вектор ошибок, возникших при
передаче. Задача декодера — определить вектор ошибок $\mathbf e$~\cite[раздел~IV]{Justesen92}.

\emph{Синдром} $\mathbf s \in \field^\mu$ определяется так:
$$\mathbf {s = H} \mathbf r^\tau = \mathbf H \mathbf e^\tau.$$
Предположим, что ошибки произошла в позициях, отвечающих точкам $(x_i,y_i)$, 
$i\in I\subset \{1, \ldots, n\}$. Обозначим 
\begin{equation}\label{KeyDecodingEq}
	S_{ab} = \sum_{i\in I} e_i x_i^a y_i^b, \quad (a,b) \letot (0,j).
\end{equation}
Неизвестными являются, как позиции ошибок $(x_i,y_i)$, так и их величины $e_i$.
Как и в классическом декодере
Пи\-тер\-со\-на—Го\-рен\-стей\-на—Цир\-ле\-ра~\cite{Blahut86} для кодов
Рида—Соломона, эти две проблемы решаются отдельно. Первая связана с введением
\emph{полинома локаторов ошибок}:
$$ \sigma(x, y) = \sum_{l,k} \sigma_{lk}x^l y^k,$$
который по определению содержит среди своих корней $\{P_i\}_{i\in I}$ и не
делится на $C(x,y)$.

Полином локаторов ошибок обладает одним важным свойством. Рассмотрим выражение
$\sum_{l,k}\sigma_{lk}S_{a+l,b+k}$:
\begin{align}\label{SynErrLocConv}
\sum_{l,k}\sigma_{lk}S_{a+l,b+k} & = \sum_{l,k}\sigma_{lk}\sum_{i\in
I} e_ix_i^{a+l}y_i^{b+k}={}\notag\\ &=\sum_{i\in I}e_ix_i^ay_i^b\sum_{l+k\leq
h}\sigma_{lk}x_l^ay_i^k=0.
\end{align}
Здесь $a$ и $b$ берутся такими, что $(a+l,b+k) \letot (0,j)$, то есть
$S_{a+l,b+k}$ имеет смысл. Последнее равенство выполняется, потому что
внутренняя сумма содержит полином $\sigma$, вычисленный в своих корнях
$P_i=(x_i,y_i)$.

Соотношения~(\ref{SynErrLocConv}) должны быть поданы на вход BMS-алгоритму.
Многочлен минимальной степени из минимального множества, полученного по
BMS-алгоритму, будет многочленом локаторов ошибок, если количество ошибок в
канале $t$ удовлетворяет неравенству~\cite[Теорема 4]{Justesen92}:
\begin{equation}\label{ErrorsBound}t<d^*/2 - m^2/8 + m/4 - 1/8.\end{equation}

После нахождения $\sigma$, нужно определить его корни из числа $\{P_i\}$,
подставить их в~(\ref{KeyDecodingEq}) и решить её относительно вектора ошибок
$\mathbf e$ одним из общих методов решения систем линейных уравнений.

В заключение сделаем замечание о границе для числа исправляемых
ошибок~(\ref{ErrorsBound}). Она более ограничительна, чем привычное для
классических (не алгебро-геометрических) помехоусточивых кодов, $t < d^*/2$.
Оказывается, в случае АГ-кодов также можно исправлять ошибки до половины
конструктивного кодового расстояния $d^*$. Это было доказано Фенгом и
Рао~\cite{FengRao93}.Применение их техники «голосования большинством» (majority
voting) к рассматриваемым кодам можно найти в~\cite{Sakata95}. Основная идея
состоит в нахождении дополнительных синдромов (для получения большего числа
уравнений~(\ref{SynErrLocConv})), используя уравнение кривой и информацию из
BMS-алгоритма на промежуточных шагах. Как ясно, это требует более тонкого
встраивания BMS-алгоритма в схему декодирования.

\subsection{Схема алгоритма декодирования}
\label{DecodingScheme}

\begin{center}\begin{tikzpicture}[node distance = 2.3cm, auto, inner sep=3pt]
	\node [cloud] (start) 	{Вход: пришедшее по каналу слово $\mathbf r$};
	\node [block, text width=5cm, below of=start, node distance = 2.5cm] (syn)
		{Вычислить синдром:\\ $\mathbf{s = H}\mathbf r^\tau$\\
		Переупорядочить его компоненты: $S_{ab}$};
	\node [block, below of=syn, text width=5cm, node distance = 3.5cm] 
		(bmsa) 
		{BMS-алгоритм\\\begin{flushleft}Вход: $\{S_{ab}\}$\\Выход: минимальное
		множество $F$\end{flushleft}};
	\node [block, text width=9cm, below of=bmsa, node distance = 3cm] 
		(locations) {Для элемента $F$ минимальной степени\\
		найти его корни среди $\{(x_i,y_i)\}$};
	\node [block, below of=locations, text width=6cm] (errors) 
		{Вычислить $\mathbf e$ из системы:\\$S_{ab} = \sum e_ix_i^ay_i^b$};
	\node [cloud, below of=errors] (finish) {Выход: $\mathbf {e}$};
	
	\path [line] (start)	 	-- (syn);
	\path [line] (syn)		 	-- (bmsa);
	\path [line] (bmsa)		 	-- (locations);
	\path [line] (locations)	-- (errors);
	\path [line] (errors)		-- (finish);
\end{tikzpicture}\end{center}

Переупорядочение в первом блоке производится с помощью 
отображения~(\ref{CantorsNumb}).

\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
В данной работе построена схема BMS\nbdash алгоритма, которая может служить
руководством для независимых реализаций. Выполнена реализация BMS\nbdash
алгоритма на языке программирования C++. Рассмотрена возможность применения
алгоритма для декодирования алгебро\nbdash геометрических кодов типа кодов
Рида\emd Соломона.

Дальнейшая работа может быть проведена по нескольким направлениям. Интерес
представляет реализация построенной в разделе~\ref{DecodingScheme} схемы
декодера. Кроме того, как отмечено в разделе~\ref{DecodingMethod}, схема может
быть усложнена для повышения числа исправляемых декодером ошибок за счёт более
сложного встраивания BMS\nbdash алгоритма в декодер.

Имеются работы, обсуждающие $n$-мерную версию BMS\nbdash
алгоритма~\cite{Sakata89} (мы рассмотрели двумерную версию), которая также может
стать предметом дальнейшей разработки и реализации. Использование её при
декодировании кодов на кривых высших размерностей также может быть проведено,
однако трудность практического применения такого кодека заключается в отсутствии
явных конструкций многомерных кривых с достаточно богатым запасом рациональных
точек~\cite{Justesen92}.

%====================================================================
\begin{thebibliography}{99}\addcontentsline{toc}{section}{\refname}

\bibitem{Shannon63ru}Шеннон К. Математическая теория связи. – В сб. «Работы по
теории информации и кибернетике». М., Иностранная литература, 1963.

\bibitem{Goppa77}Goppa~V.~D., Codes associated with divisors // Prohl. Peredach,
Inform. 1977. Vol.~13. No.~1. Pp. 33-39,

\bibitem{Tsfasman82}Tsfasman~M.~A., Vladut~S.~G., Zink~T., Modular curves,
Shimura curves and Goppa codes, better than Varshamov—Gilbert
bound // Math. Nuchr. 1982. Vol. 104. Pp. 13–28.

\bibitem{Alferov05}Алфёров~А.~П., Зубов~А.~Ю., Кузьмин~А.~С., Черёмушкин~А.~В. 
Основы криптографии: учебное пособие. — М.: Гелиос АРВ. 2005.

\bibitem{OSullivan01}O’Sullivan~M. New codes for the Berlekamp-Massey-Sakata
algorithm // Finite Fields Appl. 2001. No~7. Pp.~293–317.

\bibitem{Pelenitsyn08a}Пеленицын А.М. О реализации декодера одного класса
алгебро-геометрических кодов с использованием алгоритма Сакаты // Неделя науки
2008: сб. тезисов. Том 1. — Ростов н/Д: Изд-во ЮФУ. 2008. С. 55–57.

\bibitem{Pelenitsyn08b}Маевский А.Э., Пеленицын А.М. О программной реализации
алгебро-геометрического кодека с применением алгоритма Сакаты // В сб.
«Материалы X Международной научно-практической конференции „Информационная
безопасность“», ч.2. Таганрог. ЮФУ. 2008. С. 55–57.

\bibitem{Pelenitsyn08c}Маевский А.Э., Пеленицын А.М. Реализация программного
алгебро-геометрического кодека с применением алгоритма Сакаты // Изв. ЮФУ.
Технические науки. 2008. №8. С. 196–198.

\bibitem{Berlekamp68}Berlekamp~E. R. Algebraic Coding Theory
– New York: McGrow Hill, 1968. (Перевод: Берлекэмп Э. Алгебраическая
теория кодирования. – М.: Мир, 1971.)

\bibitem{Massey69}Massey~J.L., Shift Register Synthesis and BCH Decoding,
// IEEE Trans. Inform. Theory. 1969, Vol.~IT-15. No.~1.

\bibitem{Gashkov04}Gashkov~S.B., Gashkov~I.B. The Berlekamp-Massey Algorithm. A 
Sight from Theory of Pade Approximants and Orthogonal Polynomials // LNCS. 2004.
Vol.~3037. Pp.~561–564.

\bibitem{Kurakin94}Kurakin~V.L., Kuzmin~A.S., Mikhalev~A.V., Nechaev~A.A.
Linear recurring sequences over rings and modules // I. of Math. Science.
Contemporary Math. and it's Appl. Thematic surveys. 1994. Vol.~10. I. of Math.
Sciences. 1995. Vol.~76. №~6.

\bibitem{Kurakin99}Куракин~В.Л. Алгоритм Берлекэмпа—Месси над коммутативными
артиновыми кольцами главных идеалов // Фундаментальная и прикладная математика.
1999. Том 5. Вып. 4.

\bibitem{Sakata88}Sakata~S. Finding a minimal set of linear recurring
relations capable of generating a given finite two–dimensional array // J. Symb.
Comp. 1988. Vol.~5. Pp.~321–337.

\bibitem{Blahut86}Блейхут~Р. Теория и практика кодов, контролирующих ошибки
 — М.: Мир, 1986.

\bibitem{Justesen89}Justesen~J., Larsen~K.J., Havemose~A., Jensen~H.E., and
H\o holdt~T. Construction and Decoding of a Class of Algebraic Geometry Codes //
IEEE Trans. Inform. Theory. 1989. Vol.~35, Pp.~811–821.

\bibitem{Justesen92}Justesen~J., Larsen~K.J., Jensen~H. E., and H\o holdt~T.
Fast decoding of codes from algebraic plane curves // IEEE Trans. Inform.
Theory. 1992. Vol. 38. Pp. 111-119.

\bibitem{CppStand}ISO Information Technology — Programming Languages —
C++ Document Number ISO/IEC 14882-1998 ISO/IEC, 1998.

\bibitem{Cpp0x}Working Draft, Standard for Programming Language C++, 2009-03-23
(Черновик стандарта C++).

\bibitem{NTL}NTL: A Library for doing Number Theory by Victor Shoup,
веб-сайт: \url{http://shoup.net/ntl/}

\bibitem{Boost}Boost: C++ Libraries, веб-сайт: \url{http://www.boost.org/}

\bibitem{GMP}GNU Multiple Precision Arithmetic Library, веб-сайт: \url{http://gmplib.org/}

\bibitem{C++Templates}Вандевурд~Д., Джосаттис~Н. Шаблоны С++: справочник
разработчика. — М.: Издательский дом «Вильямс», 2003.

\bibitem{GoF}Гамма~Э., Хелм~Р., Джонсон~Р., Влиссидес~Дж. Приёмы
объект\-но-ориентированного проектирования. Паттерны проектирования. — СПб.:
Питер, 2001.

\bibitem{Sakata89}Sakata~S. N-dimensional Berlekamp-Massey algorithm for
multiple arrays and construction of multivariate polynomials with
preassigned zeros // LNCS. Vol. 357. 1989. Pp. 356–376.

\bibitem{Cox00}Кокс Д., Литтл Дж., О’Ши Д. Идеалы, многообразия и алгоритмы.
Введение в вычислительные аспекты алгебраической геометрии и коммутативной
алгебры. — М.: Мир, 2000.

\bibitem{FengRao93}Feng~G.~L., Rao~T.~R.~N., Decoding algebraic-geometric codes
up to the designed minimum distance // IEEE Trans. Inform. Theory. 1993.
Vol.~39. Pp.~37–45.

\bibitem{Sakata95}Sakata~S., Justesen~J., Madelung~Y., Jensen~H.~E., H\o
holdt~T., Fast decoding of AG-codes up to the designed minimum distance // IEEE
Trans. Inform. Theory. 1993. Vol.~41. Pp.~1672–1677.

\end{thebibliography}

\appendix
\section*{Приложение}
\addcontentsline{toc}{section}{\appendixname}
Большинство классов являются шаблонными, и, в соответствии с правилами C++,
должны целиком помещаться в заголовочные файлы. Однако для большего удобства
объявления и определения объёмных шаблонных классов разнесены в разные файлы.
При таком разделении создавался файл, содержащий всего две директивы
\texttt{\#include}, включавшие текст файла с объявлением и текст файла с
определением членов шаблонного класса — такие вспомогательные файлы не включены 
в листинг.

\input{bmsa-listings}
\end{document}
