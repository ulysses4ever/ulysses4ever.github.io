<html>
<head><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<style><!--
   span.inl-code {
      font-family : monospace;
   }
--></style>
</head>
<body>

<h1>Использование GCC</h1>
<h2>Введение</h2>
<p>Один из самых распространённых компиляторов с языков C и C++ на многих современных Unix-подобных системах, таких как GNU/Linux, члены семейства систем BSD и Mac OS X, это GCC. Первоначально эта аббревиатура расшифровывалась как GNU C Compiler (компилятор языка C от организации GNU), в свою очередь GNU является «рекурсивным акронимом», то есть расшифровывается через самое себя: GNU=GNU is Not UNIX, имея ввиду свою открытость в отличие от оригинальных систем UNIX (таких как UNIX System V от компании AT&T и BSD UNIX, разрабатывавшемся в Университете Беркли, Калифорния). После его появления в 1987 году к GCC был дописан ряд фронт-ендов (front-ends, трансляторов исходных кодов во внутреннее представление GCC, рассчитанное на дальнейшую трансляцию в исполняемый двоичный код бек-ендом, back-end) для других языков программирования:<ul><li>C++,</li> <li>Objective-C,</li> <li>Objective-C++,</li> <li>Fortran,</li> <li>Java,</li> <li>Ada,</ul> и некоторых других, а также реализации стандартных библиотек этих языков. В связи с этим участники этого проекта предложили расшифровывать название как GNU Compiler Collection (коллекция компиляторов GNU).</p>
<p>
Простейший способ задействовать средства GCC — выполнить в командной строке команду:
<pre>$ gcc <i>имя_файла</i></pre>
(<span class="inl-code">$</span> здесь и далее означает приглашение командной строки, а курсивом выделены строки, которые должны быть чем-то замещены, причем сама строка указывает на то, чем). Файл с указанным именем должен содержать исходный код на одном из языков, поддерживаемых GCC. Расширение файла может подсказать, какой именно язык используется. В частности, для C++ можно использовать такие расширения:
<div style="text-align:center;">‘.C’, ‘.cc’, ‘.cpp’, ‘.CPP’, ‘.c++’, ‘.cp’ или ‘.cxx’;</div>
для заголовочных файлов распознаются расширения:
<div style="text-align:center;">‘.hh’, ‘.hpp’, ‘.H’, или (иногда для разделяемого шаблонного кода) ‘.tcc’</div>
Тип обрабатываемого файла можно указать и явно:<pre>$ gcc <i>имя_файла</i> -x <i>тип</i></pre>Тип может быть одним из следующих (с группировкой по языкам):<ul>
<li>c  c-header  c-cpp-output</li>
<li>c++  c++-header  c++-cpp-output</li>
<li>objective-c  objective-c-header  objective-c-cpp-output</li>
<li>objective-c++ objective-c++-header objective-c++-cpp-output</li>
<li>assembler  assembler-with-cpp</li>
<li>ada</li>
<li>f95  f95-cpp-input</li>
<li>java</li>
<li>treelang</li></ul>
(Заголовочные файлы C++, как известно, не компилируются в исполняемый код, но GCC поддерживает возможность предкомпиляции заголовочных файлов, которая может повысить скорость сборки всей программы на C++ в целом, однако мы не рассматриваем здесь эту возможность.) В примерах мы будем в основном использовать язык C++ (делая иногда оговорки для случая C), файлы с расширениями ‘.cpp’ и ‘.hpp’, а также GCC версии 4.3 (посмотреть версию можно с помощью команды:
<pre>$ gcc -v</pre>). Итак, создадим в отдельном каталоге файл с простой программой на C++ и попробуем скомпилировать её из командной строки:
<pre style='color:#000000;background:#ffffff;'><span style='color:#696969; '>// first.cpp</span>
<span style='color:#004a43; '>#</span><span style='color:#004a43; '>include </span><span style='color:#800000; '>&lt;</span><span style='color:#40015a; '>iostream</span><span style='color:#800000; '>></span>

<span style='color:#800000; font-weight:bold; '>int</span> <span style='color:#400000; '>main</span><span style='color:#808030; '>(</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    <span style='color:#666616; '>std</span><span style='color:#800080; '>::</span><span style='color:#603000; '>cout</span> <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>&lt;</span> <span style='color:#800000; '>"</span><span style='color:#0000e6; '>Здравствуй, Мир!</span><span style='color:#800000; '>"</span> <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>&lt;</span> <span style='color:#666616; '>std</span><span style='color:#800080; '>::</span>endl<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>
<pre>$ gcc ./first.cpp
/tmp/cc6dArpT.o: In function `main':
first.cpp:(.text+0x1c): undefined reference to `std::cout'
first.cpp:(.text+0x21): undefined reference to `std::basic_ostream<char, std::char_traits<char> >& std::operator<< <std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&, char const*)'
first.cpp:(.text+0x29): undefined reference to `std::basic_ostream<char, std::char_traits<char> >& std::endl<char, std::char_traits<char> >(std::basic_ostream<char, std::char_traits<char> >&)'
first.cpp:(.text+0x31): undefined reference to `std::basic_ostream<char, std::char_traits<char> >::operator<<(std::basic_ostream<char, std::char_traits<char> >& (*)(std::basic_ostream<char, std::char_traits<char> >&))'
/tmp/cc6dArpT.o: In function `__static_initialization_and_destruction_0(int, int)':
first.cpp:(.text+0x60): undefined reference to `std::ios_base::Init::Init()'
first.cpp:(.text+0x65): undefined reference to `std::ios_base::Init::~Init()'
/tmp/cc6dArpT.o:(.eh_frame+0x11): undefined reference to `__gxx_personality_v0'
collect2: выполнение ld завершилось с кодом возврата 1</pre>
Не сложно догадаться, что наша первая попытка не увенчалась успехом (это можно проверить выполнив:
<pre>$ ls
first.cpp</pre>
— никаких новых файлов в каталоге для экспериментов не появилось, мы же хотели бы увидеть исполняемый файл). Чтобы понять, в чём проблема, нужно вспомнить, что создание исполняемого файла проходит в два этапа: (1) компиляция исходного текста в объектный файл, из которого затем (2) строится исполняемый файл путем линковки (‘разрешения связей’) всех необходимых средств, используемых, но не определённых в данном объектном файле. В нашем файле используются средства стандартной библиотеки (например, <span class="inl-code">std::cout</span>), которые определены в реализации GCC стандартной библиотеки C++: libstdc++.a. Хотя команда <span class="inl-code">gcc</span> самостоятельно определяет используемый язык программирования, она не считает нужным в данном случае по умолчанию линковать наш файл со стандартной библиотекой C++. Можно явно попросить её сделать это:
<pre>$ gcc ./first.cpp -lstdc++
$ ls
a.out  first.cpp
</pre>
Как видим, в каталоге появился новый файл. Попробовав его запустить, получим:
<pre>$ ./a.out 
Здравствуй, Мир!</pre>
Обратите внимание на ключ компиляции <span class="inl-code">-l</span>, сопровождаемый именем библиотеки без префикса ‘lib’ и расширения ‘.a’: мы ещё вернёмся к этому механизму и рассмотрим его более подробно. Сейчас же стоит отметить, что такое поведение <span class="inl-code">gcc</span> по умолчанию стоит признать не слишком логичным, и указать на другую возможность компиляции программ на C++:
<pre>$ rm ./a.out 
$ g++ ./first.cpp 
$ ls
a.out  first.cpp</pre>
Команда <span class="inl-code">g++</span> явно указывает на то, что мы используем язык C++ и по умолчанию линкует стандартную библиотеку этого языка.</p>

<p>Если имя ‘a.out’ кажется вам не очень выразительным, то вы наверняка захотите указать другое, делается это так:
<pre>$ g++ ./first.cpp -o helloworld
$ ls
first.cpp  helloworld</pre>
</p>

<p>Приведённые выше примеры должны натолкнуть на мысль о том, что поведением компилятора можно управлять посредством ключей (наподобие <span class="inl-code">-l</span>, <span class="inl-code">-o</span>). На самом деле, искусство использования конкретного компилятора на конкретных платформах определяется умением использовать такой набор ключей компиляции, который позволит создавать корректные и максимально эффективные программы по возможности быстро. Мы познакомимся с несколькими группами ключей GCC, приближающими к этой цели.</p>

<h2>Языковые стандарты</h2>
<p>Для каждого языка программирования, который может компилироваться GCC и для которого существует стандарт, GCC пытается следовать одной или нескольким редакциям этого стандарта, возможно, с некоторыми исключениями и, возможно, с некоторыми расширениями. Явно указать, какого стандарта нужно придерживаться при компиляции вашей программы можно, используя ключ компиляции <span class="inl-code">-std</span>, присваивая ему значения, обозначающие тот или иной стандарт, например: <pre>$ gcc ./first.cpp -lstdc++ -std=c++98</pre> скомпилирует нашу программу в режиме соответствия стандарту C++ 1998 года. Поскольку нас интересуют два языка, C и C++, посмотрим, какие из стандартов поддерживаются для них.</p>

<h3>Язык C</h3>
<p>GCC поддерживает три версии стандарта C, хотя последняя версия поддерживается лишь частично.</p>

<p>Первый стандарт C появился в 1989 как документ американской стандартизирующей организации ANSI и стал международным стандартом в следующем году, после ратицификации его международной организацией по стандартам ISO. Потребовать, чтобы GCC руководствовался именно им, можно, добавив один из трёх ключей компиляции: <span class="inl-code">-ansi</span>, <span class="inl-code">-std=c89</span> или <span class="inl-code">-std=iso9899:1990</span>.</p>

<p>В 1995 в язык была внесена первая «поправка» (amendment), которая добавила диграфы (комбинации символов, замещавших одиночные символы, которых могло не быть на некоторых клавиатурах), макрос <span class="inl-code">__STDC_VERSION__</span> для того, чтобы в исходном коде можно было проверить версию стандарта, которую поддерживает компилятор, обрабатывающий этот код, и внёсшая изменения в стандартную библиотеку. Поддержка этой редакции включается ключом <span class="inl-code">-std=iso9899:199409</span>.</p>

<p>Наконец, новая версия стандарта C была опубликована в 1999 и внесла довольно серьезные изменения в язык. Её GCC поддерживает пока не полностью, но эта поддержка включается ключом -<span class="inl-code">std=iso9899:199409</span>.</p>

<p>По умолчанию GCC использует некоторые расширения языка C, которые довольно редко конфликтуют со стандартом. Использование ключей <span class="inl-code">-std</span> со значениями, перечисленными выше, заблокирует эти расширения. Потребовать явного использования расширений можно, указав ключи <span class="inl-code">-std=gnu89</span> или <span class="inl-code">-std=gnu99</span> для стандартов 1989-го и 1999-го годов, соответственно. По умолчанию компиляция программ C происходит в режиме <span class="inl-code">-std=gnu89</span>, однажды он изменится на <span class="inl-code">-std=gnu99</span>, когда поддержка стандарта 1999-го года станет полной. Кстати, некоторые расширения GCC для стандарта 1989-го года стали частью стандарта 1999.</p>

<h3>Язык C++</h3>
<p>GCC поддерживает стандарт ISO C++ (1998 год) и предоставляет экспериментальную поддержку грядущего нового стандарта ISO, который обычно обозначают как C++0x (имея ввиду предполагаемые сроки выхода: 200x). В стандарт 1998-го года вносилась поправка в 2003-м году. GCC реализует большую часть стандарта 1998 (ключевое слово export для раздельной трансляции шаблонов C++ является важным исключением) и почти целиком поправки 2003: <span class="inl-code">-std=c++98</span>. Некоторые уже окончательно утверждённые средства C++0x можно использовать при использовании ключа <span class="inl-code">-std=c++0x</span>.</p>

<p>Как и в случае с языком C, по умолчанию GCC использует некоторые расширения языка C++, которые блокируются при указании одной из опций, описанных выше. Явное использование расширений можно затребовать, указав ключ <span class="inl-code">-std=gnu++98</span> или <span class="inl-code">-std=gnu++0x</span>, первый используется по умолчанию при компиляции программ на C++.</p>

<h2>Предупреждения компилятора</h2>
<p>Предупреждения компилятора это текстовые сообщения, которые может выдавать компилятор при обработке ваших исходных кодов. Эти сообщения указывают на некоторые нелогичные или не строгие по отношению к существующим стандартам языков программирования места в программе. Они могут сигнализировать о потенциальных ошибках или, попросту говоря, о сомнительных с точки зрения компилятора конструкциях.</p>

<p>Примерами таких потенциально опасных мест могут служить:<ul>
<li>операция <span class="inl-code">=</span> в условии оператора <span class="inl-code">if</span>, которую начинающие программисты на C или C++ часто путают с операцией <span class="inl-code">==</span>;<li>
<li>неиспользуемые переменные (вы что-то хотели присвоить им, но забыли?);</li>
<li>отсутствие указанного каталога для поиска включаемых заголовочных файлов (вы опечатались в пути для этого каталога, а соответствующий заголовочный файл взят из какого-то другого места?)</li></ul></p>

<p>Предупреждения компилятора это очень полезный механизм, позволивший программистам избежать многих незаметных на первый взгляд ошибок, которые могли проявиться только после запуска уже скомпилированной программы (возможно, много лет спустя после первого запуска). Его, безусловно, нужно использовать, и относиться к предупреждениям следует максимально внимательно. Многие авторитетные книги по C++, написанные в жанре сборников советов (Скотта Мейерса, Герба Саттера, Андрея Александреску, Стивена Дьюхерста), содержат совет компилировать программу на максимально строгом уровне предупреждений и добиваться того, чтобы компилятору не к чему было придраться.</p>

<p>Компилятор GCC позволяет включать несколько десятков видов предупреждений, для каждого из которых имеется свой ключ компиляции. Для удобства основные из них сгруппированы и включаются двумя ключами: <span class="inl-code">-Wall</span> и <span class="inl-code">-Wextra</span>. Перечислим, какие из предупреждений и соответствующих ключей оказываются задействованными при использовании этих двух и в каких случаях в результате программист будет получать предупреждения:<ul>
   <li><span class="inl-code">-Wall</span>:<ul>
         <li><span class="inl-code">-Waddress</span><br/>
         подозрительное использование адресов в памяти; например, использование имени функции (которое вернёт её адрес) в условном выражении может означать, что программист хотел вызвать эту функцию и использовать её результат, но забыл поставить круглые скобки;</li>
         <li><span class="inl-code">-Warray-bounds</span> (только вместе с ключом <span class="inl-code">-O2</span>, см. раздел ключи оптимизации)<br/>  обращения к элементам массива, которые заведомо выводят за его пределы;</li>
         <li><span class="inl-code">-Wc++0x-compat</span><br/> использование конструкций, значение которых изменится при переходе от стандарта ISO C++ 1998 к стандарту ISO C++ 200x; например, использование идентификаторов, которые станут ключевыми словами;</li>
         <li><span class="inl-code">-Wchar-subscripts</span><br/> использование выражения типа char для обращения к элементу массива (внутри квадратных скобок); источником проблем является то, что на некоторых машинах char имеет знаковый тип, а на других беззнаковый;</li>
         <li><span class="inl-code">-Wimplicit-int</span><br/> объявление не содержит типа: в C считается, что в этом случае использован int и это не приводит к синтаксической ошибке (зато часто приводит к более трудно уловимым); в C++ эта опция не нужна, так как «неявный int» запрещён и объявление без типа считается ошибкой;</li>
         <li><span class="inl-code">-Wimplicit-function-declaration</span><br/> только для C: функция используется не будучи объявленной (в C++ это вызовет ошибку компиляции);</li>
         <li><span class="inl-code">-Wcomment</span><br/> использование /* внутри уже начавшегося комментария /* (вложение комментариев не допускается и чаще всего приводит к ошибкам компиляции, но так случается не всегда);</li>
         <li><span class="inl-code">-Wformat</span><br/> проверка соответствия форматных строк в функциях printf, scanf и других переданным в них аргументам;</li>
         <li><span class="inl-code">-Wmain</span><br/> (только для C, в C++ возникнет ошибка компиляции) подозрительный тип функции main (в общем случае она должна быть функцией, возвращающей int, с внешней линковкой и имеющей 0, 2 или 3 параметра);</li>
         <li><span class="inl-code">-Wmissing-braces</span><br/> нехватка фигурных скобок в инициализации массива, например:
         <pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>int</span> a<span style='color:#808030; '>[</span><span style='color:#008c00; '>2</span><span style='color:#808030; '>]</span><span style='color:#808030; '>[</span><span style='color:#008c00; '>2</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#800080; '>{</span> <span style='color:#800080; '>{</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>,</span> <span style='color:#008c00; '>1</span> <span style='color:#800080; '>}</span><span style='color:#808030; '>,</span> <span style='color:#800080; '>{</span> <span style='color:#008c00; '>2</span><span style='color:#808030; '>,</span> <span style='color:#008c00; '>3</span> <span style='color:#800080; '>}</span> <span style='color:#800080; '>}</span><span style='color:#800080; '>;</span> <span style='color:#696969; '>// хорошо</span>
   <span style='color:#800000; font-weight:bold; '>int</span> b<span style='color:#808030; '>[</span><span style='color:#008c00; '>2</span><span style='color:#808030; '>]</span><span style='color:#808030; '>[</span><span style='color:#008c00; '>2</span><span style='color:#808030; '>]</span> <span style='color:#808030; '>=</span> <span style='color:#800080; '>{</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>,</span> <span style='color:#008c00; '>1</span><span style='color:#808030; '>,</span> <span style='color:#008c00; '>2</span><span style='color:#808030; '>,</span> <span style='color:#008c00; '>3</span> <span style='color:#800080; '>}</span><span style='color:#800080; '>;</span>      <span style='color:#696969; '>// плохо, но не является ошибкой</span>
   </pre>— на вторую строку будет выдано предупреждение;</li>
         <li><span class="inl-code">-Wnonnull</span> (только C)<br/> передача нулевого указателя на месте параметра, объявленного с ключевым словом nonnull;</li>
         <li><span class="inl-code">-Wparentheses</span><br/> возможно, не хватает скобок (любого типа); например, предупреждение появится для выражения ‘x<=y<=z’, которое эквивалентно ‘(x<=y ? 1 : 0) <= z’, что противоречит привычному математическому смыслу двойного неравенства, который, вероятней всего, имел ввиду программист;</li>
         <li><span class="inl-code">-Wpointer-sign</span> (только C)<br/> передача указателей или присваивание с различной «знаковостью» (между знаковыми и беззнаковыми типами);</li>
         <li><span class="inl-code">-Wreorder</span> (только C++)<br/> порядок членов в списке инициализации конструктора класса или структуры не соответствует порядку их объявления;</li>
         <li><span class="inl-code">-Wreturn-type</span><br/> объявление функции без возвращаемого типа, отсутствие <span class="inl-code">return</span> в не-<span class="inl-code">void</span> функции, наличие <span class="inl-code">return</span> у <span class="inl-code">void</span> функции; в C++ сообщение об отсутствующем <span class="inl-code">return</span> будет подано в любом случае, а отсутствие типа в объявлении считается ошибкой;</li>
         <li><span class="inl-code">-Wsequence-point</span><br/>
         указывает на выражения, порядок вычисления которых не специфицирован стандартом и потому зависит от реализации (попросту говоря, непредсказуем), например: <span class="inl-code">a = a++;</span>,  <span class="inl-code">a[n] = b[n++];</span>;</li>
         <li><span class="inl-code">-Wsign-compare</span> (только для C++)<br/> сравнение знаковых и беззнаковых выражений;</li>
         <li><span class="inl-code">-Wstrict-aliasing</span> (активно только если указан ключ оптимизации <span class="inl-code">-fstrict-aliasing</span>)<br/>
         преобразование типов небезопасное относительно оптимизаций компилятора, которые он выполняет на основе предположения о том, что любой участок памяти используется только для значений одного типа (или очень похожих типов);</li>
         <li><span class="inl-code">-Wstrict-overflow=1</span> (активно только если указан ключ оптимизации <span class="inl-code">-fstrict-overflow</span>)<br/> предупреждает о возможных переполнениях типа в тех местах, где компилятор собирается выполнить оптимизацию, основанную на предположении об отсутствии переполнения;</li>
         <li><span class="inl-code">-Wswitch</span><br/>при использовании переменной типа <span class="inl-code">enum</span> в операторе <span class="inl-code">switch</span> одно или несколько значений этого <span class="inl-code">enum</span> не перечислено в <span class="inl-code">case</span> (наличие <span class="inl-code">default</span> подавляет это предупреждение); метки <span class="inl-code">case</span> проверяющие значения за пределами данного <span class="inl-code">enum</span> также вызовут предупреждение;</li>
         <li><span class="inl-code">-Wtrigraphs</span><br/>триграф используется вне комментария и может изменить смысл программы (триграф это последовательность символов, обозначающая некоторый специальный символ; задумывались для использования в тех странах, где клавиатуры не содержали необходимых для программирования символов, но сейчас абсолютно устарели);</li>
         <li><span class="inl-code">-Wuninitialized</span> (только при оптимизации с ключом <span class="inl-code">-O1</span> или выше)<br/>переменная не инициализирована или может оказаться таковой в результате использования <span class="inl-code">setjmp</span>;</li>
         <li><span class="inl-code">-Wunknown-pragmas</span><br/>встречена директива компиляции <span class="inl-code">#pragma</span> с неизвестным GCC именем;</li> 
         <li><span class="inl-code">-Wunused-function</span><br/>статическая функция объявлена, но не определена, или невстраиваемая статическая функция определена, но не используется;</li>
         <li><span class="inl-code">-Wunused-label</span><br/>метка объявлена но не использована;</li>
         <li><span class="inl-code">-Wunused-value</span><br/>значение выражения, не имеющего сторонних эффектов, нигде не используется;</li>
         <li><span class="inl-code">-Wunused-variable</span><br/>локальная переменная или статическая неконстантная переменная не используется нигде кроме своего объявления;</li>
      </ul>
   </li>
   <li><span class="inl-code">-Wextra</span> (известна также как <span class="inl-code">-W</span>: это имя до сих пор поддерживается, но считается устаревшим и не рекомендуется к использованию в новых проектах):<ul>
         <li><span class="inl-code">-Wclobbered</span><br/>переменная может быть изменена вызовами <span class="inl-code">longjmp</span> или <span class="inl-code">vfork</span>;</li>
         <li><span class="inl-code">-Wempty-body </span><br/>пустое тело у <span class="inl-code">if</span>, <span class="inl-code">else</span> или <span class="inl-code">do-while</span>; в C++ также будет выдано предупреждение для пустого тела циклов <span class="inl-code">while</span> и <span class="inl-code">for</span>, если перед <span class="inl-code">;</span>, закрывающей цикл, не стоит пробельного символа (пустые <span class="inl-code">{}</span> не вызовут предупреждения);</li>
         <li><span class="inl-code">-Wignored-qualifiers</span><br/>использован квалификатор типа (например, <span class="inl-code">const</span>) для типа возвращаемого значения функции; в C++ это предупреждение возникнет только для скалярных встроенных типов и void в качестве возвращаемых типов;</li>
         <li><span class="inl-code">-Wmissing-field-initializers</span><br/>пропущена инициализация одного из полей структуры;</li>
         <li><span class="inl-code">-Wmissing-parameter-type</span> (только C)<br/>пропущен тип параметра функции в её объявлении;</li>
         <li><span class="inl-code">-Wold-style-declaration</span> (только C)<br/>использован какой-либо стиль объявлений, признанный стандартом C устаревшим (например, <span class="inl-code">static</span> не на первом месте в объявлении);</li>
         <li><span class="inl-code">-Woverride-init</span> (только C)<br/>инициализация поля без сторонних эффектов перекрывается при последующем использовании «назначенных инициализаций» (designated initializers);</li>
         <li><span class="inl-code">-Wsign-compare</span><br/>см. описание этого ключа в разделе <span class="inl-code">-Wall</span>;</li>
         <li><span class="inl-code">-Wtype-limits</span><br/>сравнение (обычно на неравенство) всегда имеет значение ‘истина’ (или всегда ‘ложь’) из-за ограничений типов; например, сравнение беззнаковой переменной с нулём;</li>
         <li><span class="inl-code">-Wuninitialized</span><br/>см. описание этого ключа в разделе <span class="inl-code">-Wall</span>;</li>
         <li><span class="inl-code">-Wunused-parameter</span> (только в присутствии <span class="inl-code">-Wall</span> или <span class="inl-code">-Wunused</span>)<br/>неиспользуемый параметр функции.</li>
         <span class="inl-code">-Wextra</span> также выдаёт предупреждения в следующих случаях:
         <li>указатель сравнивается с нулём с помощью <span class="inl-code"><</span>, <span class="inl-code"><=</span>, <span class="inl-code">></span> или <span class="inl-code">>=</span>.</li>
         Следующие опции имеют смысл только для C++:
         <li>члены <span class="inl-code">enum</span> используются в одном условном выражении вместе с не-членами этого <span class="inl-code">enum</span>;</li>
         <li>нестатическое поле-ссылка или нестатическое константное поле в классе без конструктора;</li>
         <li>неоднозначность с виртуальными базовыми классами;</li>
         <li>обращение к элементу массива, объявленному как <span class="inl-code">register</span>;</li>
         <li>взятие адреса переменной, объявленной как <span class="inl-code">register</span>;</li>
         <li>базовый класс не инициализирован в копирующем конструкторе класса-наследника.</li>
      </ul></li>
</ul>
</p>

<p>После знакомства с концепцией предупреждений компилятора и поддерживаемыми стандартами языков, стоит заметить, что стандарты сами содержат набор рекомендаций к производителям компиляторов для генерации предупреждений. Включить соответствующие предупреждения можно указав для команды компиляции ключ <span class="inl-code">-pedantic</span> (это можно делать независимо от того, указаны ли другие ключи).</p>

<p>Далее в примерах при использовании GCC мы не будем указывать опции, включающие предупреждения, чтобы не загромождать код. Мы даём честное слово, что на практике всегда используем максимальный уровень предупреждений и рекомендуем вам делать то же.</p>

<h2>Отладочная информация</h2>

<p>Сложно представить себе программу, которая выполняет что-то осмысленное и которая была написана с первого раза без единой ошибки. Хуже того, иногда может оказаться, что давно и успешно работающая программа также содержит изъяны. Установить источник проблем помогает отладочная информация, которую компилятор может добавить в каждый объектный файл. Она включает в себя указание на типы данных, использованные в программе, и соответствие объектного кода строкам текста исходного файла. Отладочная информация, сгенерированная GCC, предполагается для использования в первую очередь отладчиком GDB (GNU debugger, отладчик GNU), но не только им.</p>

<p>Некоторую сложность представляет тот факт, что на разных платформах используются разные форматы отладочной информации, кроме того, на разных платформах могут более эффективно  использоваться «родные» для данной платформы отладчики. Перечислим форматы, поддерживаемые GCC:<ul>
<li><strong>stabs</strong> — используется отладчиком DBX на большинстве BSD-систем. На системах MIPS, Alpha и System V Release 4 эта опция даст результат, котрый не будет понят DBX или другим распространённым отладчиком SDB. На системе System V Release 4 потребует наличие GNU Assembler (ассемблера GNU).</li>
<li><strong>COFF</strong> — используется отладчиком SDB на большинстве System V, до версии System V Release 4.</li>
<li><strong>XCOFF</strong> — используется отладчиком DBX на системах IBM RS/6000.</li>
<li><strong>DWARF 2</strong> — используется DBX на IRIX 6.</li>
<li><strong>VMS</strong> — используется программой DEBUG на системах VMS.</li>
</ul></p>

<p>Каждый из перечисленных форматов может быть использован, только если он поддерживается текущей платформой. Указать формат можно с помощью ключа <span class="inl-code">-g<i>имя_формата_строчными_буквами</i></span>. Для форматов stabs и COFF можно добавить к ключу символ ‘+’ справа без пробела, это включит дополнительную информацию, специфичную для GDB и может помешать работе других отладчиков с этим файлом.</p>

<p>Указав ключ <span class="inl-code">-g</span>, можно получить информацию в формате, родном для текущей архитектуры (но будут использоваться расширения, специфичные для GDB). Самая подробная с точки зрения GDB отладочная информация, доступная на данной платформе, будет сгенерирована при использовании ключа <span class="inl-code">-ggdb</span> (будет использован максимально выразительный доступный на данной платформе формат).</p>

<p>К каждому из упомянутых ключей можно дописать справа цифру от 0 до 3, она будет обозначать <em>уровень отладочной информации</em>, иначе говоря — её объем:<ul>
   <li>Уровень 0 отключает генерацию отладочной информации.</li>
   <li>Уровень 1 обеспечивает минимум отладочной информации, позволяющей просматривать стеки вызовов подпрограмм, которые вы не планировали отлаживать. Включаются описания функций и внешних переменных, но отсутствует информация о локальных переменных и номерах строк исходного кода.</li>
   <li>Уровень 2 используется по умолчанию и добавляет к уровню 1 информацию о локальных переменных и номерах строк исходного кода.</li>
   <li>Уровень 3 включает дополнительную информацию, например, определения макросов.</li>
</ul></p>

<p>В заключение этого пункта следует сказать ещё две вещи. Во-первых, как и многие современные компиляторы, GCC поддерживает разные уровни оптимизации генерируемого кода, они задаются ключом <span class="inl-code">-O</span> и сопутствующими. Некоторые современные компиляторы в то же время не позволяют использовать одновременно отладочную информацию и оптимизацию, другими словами, ключи семейств <span class="inl-code">-g</span> и <span class="inl-code">-O</span> конфликтуют. Последнее не относится к GCC: он позволяет совмещать указанные возможности. При этом отладка может выявить интересные эффекты оптимизации: например, строки кода исполняются в неожиданном порядке, некоторые из них просто пропускаются, некоторые объявленные переменные могут исчезнуть (не проявляться при отладке).</p>

<p>Во-вторых, отладочная информация все же занимает дополнительное пространство в памяти (темпы удешевления которой, впрочем, настолько высоки, что вряд ли можно оправдать пренебрежительное отношение к генерации отладочной информации), которое вы можете захотеть сэкономить. Для этого существует ключ <span class="inl-code">-s</span> (от strip — удалить). Размер файлов с отладочной информацией и без неё может отличаться довольно сильно, особенно на маленьких программах. Сравним размеры исполняемых файлов нашей первой программы в трёх случаях:<ol><li>C ключом <span class="inl-code">-s</span>.</li><li>Без каких-либо ключей, касающихся отладки.</li><li>С ключом <span class="inl-code">-ggddb3</span>, который должен поместить довольно много отладочной информации в исполняемый файл.</li></ol>
<pre>$ g++ -s ./first.cpp -o hw-1-s
$ g++ ./first.cpp -o hw-2
$ g++ -ggdb3 ./first.cpp -o hw-3-gddb3
$ ls -l | grep 'hw*' | awk '{printf "%-10s: %5s B\n", $8, $5}'
hw-1-s    :  5736 B
hw-2      :  9747 B
hw-3-gddb3: 89827 B</pre>
</p>

<h2>Оптимизация</h2>
<p>Если с предупреждениями компилятора всё ясно (действует принцип «чем больше, тем лучше»), количество отладочной информации также, в основном, контролируется программистом в соответствии с его целями (доведение программы до работоспособного состояния или изготовление окончательной версии программы для передачи заказчику), то с оптимизацией дело обстоит намного сложней. Оптимизация это процесс улучшения производительности программы, в том числе, увеличение скорости её работы и снижение объёма занимаемой памяти (эти две цели, между прочим, иногда противоречат друг другу). GCC поддерживает большой набор ключей оптимизации и часть из них объединены в группы (как и в случае с предупреждениями), что позволяет активировать их также по групповому принципу.</p>

<p>Возникает закономерный вопрос: если есть ключи, ускоряющие программу, почему бы не включить их все разом и получить самый быстрый код? Проблема состоит в том, что эффективность значительной части средств для увеличения производительности программы сильно зависит от характера оптимизируемого кода и архитектуры аппаратной платформы. Оптимизация, таким образом, превращается в искусство отражения конкретных особенностей реализации и имеющегося аппаратного обеспечения на существующие ключи компилятора. Кроме того, результат этой деятельности, вероятно, окажется плохо или просто непереносимым. Неудачный выбор ключей, с другой стороны, может обеспечить гарантированное и весьма существенное падение производительности.</p>

<p>Мы упомянем только несколько ключей, обозначающих группы опций оптимизации, которые были подобраны разработчиками GCC и позволяют улучшить производительность во многих случаях, оставив рассмотрение отдельных опций и их связь с особенностями аппаратного обеспечения для более специализированных публикаций.</p>

<p>Если компилятор не получает каких-либо флагов оптимизации, его основная цель — снизить время компиляции (которое при сборках больших программ на C или C++ может достигать внушительных показателей и, тем самым, сильно тормозить процесс разработки) и обеспечить предсказуемость и корректность процедуры отладки (если она будет производиться в будущем). Групповые флаги оптимизации имеют вид: <span class="inl-code">-O<i>уровень</i></span>, где уровень может изменяться от 0 до 3 (каждый следующий включает в себя все оптимизации предыдущего).<ul>
<li><span class="inl-code">-O1</span> (также носит обозначение <span class="inl-code">-O</span>, признанное устаревшим)<br>Мягкая оптимизация, некоторое увеличение времени компиляции, возможно ощутимое увеличение памяти для больших функций; включены оптимизации, которые должны одновременно уменьшать общую занимаемую память и ускорять код.</li>
<li><span class="inl-code">-02</span><br>Включает практически все доступные оптимизации, не ухудшающие сильно один из двух показателей двоичного кода — память или скорость — за счёт другого; не включает развертку циклов и автоматическое встраивание функций.</li>
<li><span class="inl-code">-O3</span><br>Наиболее «агрессивная» оптимизация, включаются развертку циклов и автоматическое встраивание функций.</li>
<li><span class="inl-code">-O0</span><br>Отключение оптимизаций, основная цель: высокая скорость компиляции и предсказуемость результатов отладки; эта опция задействована по умолчанию.</li>
<li><span class="inl-code">-Os</span><br>Оптимизация размера программы. Включаются те опции из набора <span class="inl-code">-O2</span>, которые обычно не увеличивают объём кода. Также применяются некоторые другие оптимизации, направленные на снижение его объёма.</li>
</ul>
Компилятору должен быть передан единственный флаг из перечисленных, иначе будет использован последний переданный.</p>

<h2>Раздельная трансляция</h2>

<p>Реальные программы сильно превышают размеры нашего первого примера ‘first.cpp’ по количеству строк кода. Когда оно увеличивается достаточно сильно, появляются проблемы:<ul>
<li>любое изменение в тексте файла с программой приводит к его полной перекомпиляции, что занимает ощутимое время;</li>
<li>сложно организовать коллективную разработку (согласовать внесение изменений в один файл несколькими программистами);</li>
<li>затрудняется навигация по созданному коду.</li></ul>
Таким образом, встает необходимость разбиения текста программы на несколько файлов.</p>

<p>Начнём с простого случая, когда программа представляет из себя набор функций, и мы хотим вынести их часть в отдельный ‘.cpp’-файл. Возьмём уже использовавшийся пример с программой ‘first.cpp’ и добавим в неё вызов функции, определение которой помещается в файле ‘second.cpp‘:
<pre style='color:#000000;background:#ffffff;'><span style='color:#696969; '>// first.cpp</span>
<span style='color:#004a43; '>#</span><span style='color:#004a43; '>include </span><span style='color:#800000; '>&lt;</span><span style='color:#40015a; '>iostream</span><span style='color:#800000; '>></span>

<span style='color:#800000; font-weight:bold; '>using</span> <span style='color:#666616; '>std</span><span style='color:#800080; '>::</span>endl<span style='color:#800080; '>;</span>

<span style='color:#800000; font-weight:bold; '>int</span> f<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>

<span style='color:#800000; font-weight:bold; '>int</span> <span style='color:#400000; '>main</span><span style='color:#808030; '>(</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    <span style='color:#666616; '>std</span><span style='color:#800080; '>::</span><span style='color:#603000; '>cout</span> <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>&lt;</span> <span style='color:#800000; '>"</span><span style='color:#0000e6; '>Здравствуй, Мир!</span><span style='color:#800000; '>"</span> <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>&lt;</span> endl
        <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>&lt;</span> f<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>&lt;</span> endl<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>
<pre style='color:#000000;background:#ffffff;'><span style='color:#696969; '>// second.cpp</span>
<span style='color:#800000; font-weight:bold; '>int</span> f<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span><span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#008c00; '>42</span><span style='color:#800080; '>;</span><span style='color:#800080; '>}</span>
</pre>
Обратите внимание на объявление <span class="inl-code">int f();</span> в ‘first.cpp’: правила языка C++ требуют объявить каждую функцию перед первым использованием. Обычно вместо того, чтобы вручную писать объявления всех функций, определённых в другой единице трансляции (‘.cpp’-файле), используют заголовочные файлы, содержащие все необходимые объявления, текст которых целиком включается в нужный ‘.cpp’-файл директивой препроцессора C <span class="inl-code">#include</span>. Обычно для каждого ‘.cpp’-файла, который не содержит точки входа в программу (функции <span class="inl-code">main</span>), а значит, содержимое которого будет использовано другими частями программы, создаётся заголовочный файл с таким же основным именем, но другим расширением. В нашем примере можно добавить заголовочный файл ‘second.hpp’ и получить эквивалентный приведённому выше, но в перспективе более удобный в использовании код:
<pre style='color:#000000;background:#ffffff;'><span style='color:#696969; '>// first.cpp</span>
<span style='color:#004a43; '>#</span><span style='color:#004a43; '>include </span><span style='color:#800000; '>&lt;</span><span style='color:#40015a; '>iostream</span><span style='color:#800000; '>></span>
<span style='color:#004a43; '>#</span><span style='color:#004a43; '>include </span><span style='color:#800000; '>"</span><span style='color:#40015a; '>second.hpp</span><span style='color:#800000; '>"</span>

<span style='color:#800000; font-weight:bold; '>using</span> <span style='color:#666616; '>std</span><span style='color:#800080; '>::</span>endl<span style='color:#800080; '>;</span>

<span style='color:#800000; font-weight:bold; '>int</span> <span style='color:#400000; '>main</span><span style='color:#808030; '>(</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>
    <span style='color:#666616; '>std</span><span style='color:#800080; '>::</span><span style='color:#603000; '>cout</span> <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>&lt;</span> <span style='color:#800000; '>"</span><span style='color:#0000e6; '>Здравствуй, Мир!</span><span style='color:#800000; '>"</span> <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>&lt;</span> endl
        <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>&lt;</span> f<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>&lt;</span><span style='color:#808030; '>&lt;</span> endl<span style='color:#800080; '>;</span>
<span style='color:#800080; '>}</span>
</pre>
<pre style='color:#000000;background:#ffffff;'><span style='color:#696969; '>// second.hpp</span>
<span style='color:#004a43; '>#</span><span style='color:#004a43; '>ifndef</span><span style='color:#004a43; '> SECOND_HPP</span>
<span style='color:#004a43; '>#</span><span style='color:#004a43; '>define</span><span style='color:#004a43; '> SECOND_HPP</span>
<span style='color:#800000; font-weight:bold; '>int</span> f<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>
<span style='color:#004a43; '>#</span><span style='color:#004a43; '>endif</span>
</pre>
<pre style='color:#000000;background:#ffffff;'><span style='color:#696969; '>// second.cpp</span>
<span style='color:#800000; font-weight:bold; '>int</span> f<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span><span style='color:#800000; font-weight:bold; '>return</span> <span style='color:#008c00; '>42</span><span style='color:#800080; '>;</span><span style='color:#800080; '>}</span>
</pre>
Директивы препроцессора C (строки, начинающиеся <span class="inl-code">#</span>) в заголовочном файле — «стражи включения», — как обычно, добавляются для того, чтобы данный файл не был по случайности включён в один ‘.cpp’-файл несколько раз (символ <span class="inl-code">SECOND_HPP</span> должен быть своим у каждого заголовочного файла, потому разумно связывать его с именем этого файла).</p>

<p>Вернёмся от увлекательных особенностей C++ к использованию GCC. Оба указанных выше варианта компилируются и линкуются в один исполняемый файл одинаково, при помощи простого перечисления:
<pre>$ g++ ./first.cpp ./second.cpp -o hw42
$ ./hw42
Здравствуй, Мир!
42</pre>
Стоит отметить удобную возможность использования шаблонов имён (wildcards), чтобы избежать полного перечисления файлов: 
<pre>$ g++ ./*.cpp -o hw42</pre>
даст аналогичный приведённому выше результат.</p>

<p>Итак, мы сумели разнести код в несколько файлов, но пока еще не добились того, чтобы изменения в одном файле не приводили к перекомпиляции всех. Здесь снова придется вспомнить о том, что используемые до этого момента вызовы <span class="inl-code">gcc</span> (<span class="inl-code">g++</span>) приводят не только к компиляции, но и к линковке полученных после компиляции объектных фалов в один исполняемый файл. Нам потребуется явно разбить создание исполняемого файла на две стадии, используя ключ <span class="inl-code">gcc</span> <span class="inl-code">-с</span>, который просит оставить получившиеся объектные файлы на диске и не линковать их:
<pre>$ g++ ./*.cpp -c
$ ls | grep '\.o$'
first.o
second.o</pre>
Как видно, на диске появились два объектных файла (расширение ‘.o’), которые, очевидно, соответствуют исходным ‘.cpp’. Слинковать и получить исполняемый файл можно обычным образом:
<pre>$ g++ ./*.o -o hw-from-o
$ ./hw-from-o 
Здравствуй, Мир!
42</pre>
(GCC определяет тип файлов и не пытается компилировать их как исходные тексты, а сразу линкует). Теперь, внеся изменение в файл ‘second.cpp’, можно перекомпилировать только его и заново слинковать все объектные файлы программы:
<pre>$ g++ ./second.cpp -c
$ g++ ./*.o -o hw42-v.2</pre>
Не поленитесь исправить в тексте ‘second.cpp’ 42 на ваше любимое число и убедиться, что эта схема работает.</p>

<h2>Библиотеки</h2>
<p>Раздельная трансляция файлов делает доступным систематическое повторное использование кода: набор объектных файлов, содержащих функции, которые могут быть использованы в разных программах, собирается в <em>библиотеку (программного кода)</em>, представляющую собой единый файл, который содержит весь код объектных с некоторой дополнительной информацией (наподобие индекса в настоящих библиотеках). Последнее может ускорять процесс линковки при использовании библиотеки по сравнению с обычной сборкой программы из большого числа объектных файлов. Информация об исходных объектных файлах также сохраняется.</p>

<p>Библиотеки могут существовать в двух различных вариантах:<ul>
<li><em>статические</em>: код из библиотеки добавляется в исполняемый файл на стадии линковки, и после её окончания файл библиотеки больше не нужен полученной программе;</li>
<li><em>динамические</em>: код из библиотеки не добавляется в исполняемый файл, а загружается в память во время запуска программы, таким образом, он должен быть доступен при каждом запуске;</li></ul></p>

<p>Бесспорное преимущество динамических библиотек состоит в том, что если несколько программ используют одну библиотеку, то она загружается в память только один раз. Иными словами, сразу несколько программ могут (и будут) использовать один загруженный экземпляр библиотеки «одновременно». В то же время использование статической библиотеки заставит добавлять части её кода в каждый исполняемый файл по отдельности. Обновление динамической библиотеки потребует перезапуска, использующих её программ, статической — их перелинковки (что обычно занимает немало времени).</p>

<h3>Статические библиотеки</h3>
<p>Рассмотрим сначала более простой случай статической библиотеки. Для создания библиотеки такого типа из набора объектных файлов используется утилита <span class="inl-code">ar</span>. Добавим к двум имеющимся ‘.cpp’-файлам третий, ‘third.cpp’ (с произвольным содержимым), скомпилируем его в объектный файл и сделаем из двух объектных (‘second.o’, ‘third.o’) статическую библиотеку:
<pre>$ g++ -c ./third.cpp 
$ ar crs libfirst.a ./second.o ./third.o
$ ls | grep '\.a'
libfirst.a</pre>
Опции <span class="inl-code">ar</span> означают следующее: <ul><li><span class="inl-code">c</span> — создать (create) библиотеку,</li><li><span class="inl-code">r</span> — заменить (replace) совпадающие объектные файлы внутри библиотеки указанными новыми (в случае, если библиотека существовала),</li><li><span class="inl-code">s</span> — создать индекс внутри библиотеки (может быть, у вас получится догадаться о происхождении имени ключа...).</li></ul>
<strong>Важным</strong> является формат имени файла библиотеки:<ul><li>префикс ‘lib’,</li><li>расширение ‘.a’.</li></ul>
</p>

<p>Для указания GCC на библиотеки, которые нужно использовать при сборке, понадобятся ещё два ключа:<ul><li><span class="inl-code">l</span> — для имени библиотеки,</li><li><span class="inl-code">L</span> — для указания пути к ней.</li></ul>Компиляция нашей программы с использованием созданной библиотеки может выглядеть так:
<pre>$ g++ ./first.cpp -L. -lfirst</pre>
С помощью <span class="inl-code">-L.</span> текущий каталог добавляется в список каталогов для поиска библиотек (чтобы добавить несколько каталогов, нужно использовать ключ <span class="inl-code">-L</span> несколько раз). Обратите внимание, что <em>именем библиотеки считается подстрока имени ‘.a’-файла между ‘lib’ слева и ‘.a’ справа</em>. Здесь, в отличие от рассмотренных ранее случаев, порядок аргументов <span class="inl-code">g++</span> важен, поскольку <span class="inl-code">-L</span> и <span class="inl-code">-l</span> это опции линковщика, который вступает в работу <em>после</em> компилятора, обрабатывающего первый аргумент (имя файла).</p>

<h3>Динамические библиотеки</h3>
<p>Создание и использование динамической библиотеки более сложны. При компиляции исходных файлов в объектные, которые станут основой для будущей библиотеки, нужно указать один дополнительный ключ:
<pre>$ g++ -fPIC -c ./second.cpp</pre>
(мы не упоминаем файл ‘third.cpp’, чтобы не загромождать год: создадим библиотеку из одного файла). Ключ <span class="inl-code">-fPIC</span> позволяет создавать <em>независимый от размещения в оперативной памяти код</em> (position independent code), что позволяет использовать один библиотечный код из разных программ (находящихся, очевидно, в разных местах оперативной памяти) во время их выполнения.  Будем для краткости называть результирующий файл этой команды так: объектный pic-файл. Можно вместо ключа <span class="inl-code">-fPIC</span> использовать <span class="inl-code">-fpic</span> аналогичного назначения, который может создать файл меньшего размера, но работает не на всех платформах. Если на вашей платформе он не поддерживается, GCC сообщит вам об этом.</p>

<p>Файлы динамических библиотек должны, как и раньше, иметь префикс ‘lib’ и расширение ‘.so’ (shared object). Сложность состоит в том, что для одной библиотеки надо иметь в виду четыре имени, причем три из них соответствуют объектам файловой системы:<ol>
   <li>«Реальное имя» (real name): имя файла на диске, содержащего код библиотеки. Должно иметь форму:
   <div style="text-align:center;">lib<i>имя</i>.so.<i>n</i>.<i>m</i>.<i>k</i></div>где<ul><li><span class="inl-code">n</span> это номер версии библиотеки,</li><li><span class="inl-code">m</span> это номер промежуточной («минорной») версии данной версии библиотеки,</li><li><span class="inl-code">k</span> это номер «релиза» промежуточной версии библиотеки.</li></ul>Номер релиза с предшествующей точкой можно опускать, что мы и будем делать в дальнейшем.</li>
   <li>«so-имя» (<strong>soname</strong>) получается из реального имени удалением минорной версии и релиза (если он указан):<div style="text-align:center;">lib<i>имя</i>.so.<i>n</i></div>
   В одном каталоге с файлом библиотеки (для которого используется «реальное имя») должна существовать мягкая ссылка (soft link) на него, имеющая so-имя этой библиотеки. Эти мягкие ссылки создаются для всех библиотек в указанном каталоге с помощью запуска утилиты <span class="inl-code">ldconfig</span> либо вручную для конкретной библиотеки с помощью утилиты <span class="inl-code">ln</span>:<ul><li><span class="inl-code">$ ldconfig -n /<i>путь</i>/<i>к</i>/<i>каталогу</i></span></li><li><span class="inl-code">$ ln -s /<i>путь</i>/<i>к</i>/<i>каталогу</i>/lib<i>имя</i>.so.<i>n</i>.<i>m</i> /<i>путь</i>/<i>к</i>/<i>каталогу</i>/lib<i>имя</i>.so.<i>n</i></span></li></ul></li>
   <li>Имя, используемое линковщиком при создании исполняемого файла. Не содержит информации о версиях:<div style="text-align:center;">lib<i>имя</i>.so</div>Обычно в каталоге с файлом библиотеки создаётся мягкая ссылка с этим именем на so-имя (ссылка с so-именем должна уже существовать) либо на реальное имя (первый вариант часто удобней):
   <pre>$ ln -s /<i>путь</i>/<i>к</i>/<i>каталогу</i>/lib<i>имя</i>.so.<i>n</i> /<i>путь</i>/<i>к</i>/<i>каталогу</i>/lib<i>имя</i>.so</pre></li>
   <li>Имя библиотеки для передачи при вызове компилятора (линковщика) с ключом <span class="inl-code">-l</span>. Аналогично статическим библиотекам, это подстрока между ‘lib’ и ‘.so’.</li>
</ol></p>

<p>Рассмотрим команду получения файла библиотеки (который должен носить «реальное имя», п. 1 списка выше) из объектного pic-файла:
<pre>$ g++ -shared -Wl,-soname,libfirst.so.1 -o libfirst.so.1.0 ./second.o</pre>
Ключ <span class="inl-code">-shared</span> имеет вполне понятное значение: мы сигнализируем GCC о том, что хотим получить динамическую библиотеку («разделяемый объект»). После ключа <span class="inl-code">-o</span> идёт имя выходного файла («реальное имя» файла нашей библиотеки), а затем список файлов, которые должны в эту библиотеку войти: в нашем случае это всего один объектный файл ‘second.cpp’.</p>

<p>Теперь попробуем разобраться с тем, что написано между ключами <span class="inl-code">-shared</span> и <span class="inl-code">-o</span>. Ключ <span class="inl-code">-Wl</span> говорит о том, что далее пойдут опции, которые предназначаются непосредственно линковщику. В соответствии с синтаксическими правилами, в списке этих опций не должно присутствовать пробелов: мы передаём GCC что-то, на что он должен «закрыть глаза» (опции предназначены не ему, а линковщику) и в этом случае мы договариваемся о том, что он откроет глаза только когда встретит первый пробел. В качестве символа-разделителя в списке этих опций вместо пробела выступает запятая. Теперь должно быть ясно, что между ключами <span class="inl-code">-shared</span> и <span class="inl-code">-o</span> стоит опция, передаваемая линковщику, которая указывает на «so-имя» (п. 2 списка выше) создаваемой библиотеки.</p>

<p>Такое усложнение возникает из основного принципа работы GCC (как и большинства Unix-программ): решаемая задача неявно разбивается на подзадачи, которые выполняют отдельные утилиты. Это создаёт некоторый уровень абстракции: для большинства операций мы просто вызываем команду <span class="inl-code">g++</span> и не задумываемся, какие именно программы трудятся над обработкой наших файлов, а зачастую их (программ) бывает немало. В случае с <span class="inl-code">-Wl</span> мы натолкнулись на явление, которое Джоэль Спольски назвал «протекающими абстракциями» (его статью «Закон дырявых абстракций» на эту тему можно и сейчас найти в интернете). Более прозрачное решение текущей задачи (получение библиотечного файла из объектного(ых) pic-файла(ов)) состоит в прямом вызове линковщика, минуя <span class="inl-code">g++</span>:<pre>
$ ld -shared -soname libfirst.so.1 -o libfirst.so.1.0 ./second.o
</pre>Результат в данном случае будет аналогичным.</p>

<p>Обсудим теперь процесс загрузки библиотек в память. Он, как было сказано, происходит при запуске первой программы, которая использует данную динамическую библиотеку. Загрузка необходимых библиотек при запуске программы осуществляется специальной программой, являющейся частью операционной системы — <em>динамическим линковщиком</em>. Он ищет файлы библиотек в некоторых заранее определённых каталогах, список которых на многих Unix-подобных операционных системах хранится в файле <span class="inl-code">/etc/ld.so.conf</span>. Почти наверняка в этом списке имеются каталоги <span class="inl-code">/lib</span> и <span class="inl-code">/usr/lib</span>. Возможно, сюда входит и <span class="inl-code">/usr/local/lib</span>. Как это часто бывает, разные авторитетные организации и специалисты советуют использовать для динамических библиотек разные папки. Мы остановим свой выбор на <span class="inl-code">/usr/lib</span>. Создание необходимой инфраструктуры библиотечных файлов: одного реального, ссылки с so-именем и ссылки с именем для линковщика — в каком-то из системных каталогов для хранения библиотек часто называют <em>установкой библиотеки</em>.</p>

<p>Теперь, наконец, посмотрим на весь путь от создания динамической библиотеки до запуска программы, её использующей:<pre>
$ g++ -fPIC -c ./second.cpp
$ ld -shared -soname libfirst.so.1 -o libfirst.so.1.0 ./second.o
$ sudo cp ./libfirst.so.1.0 /usr/lib/libfirst.so.1.0
$ sudo ldconfig -n /usr/lib/
$ sudo ln -s /usr/lib/libfirst.so.1 /usr/lib/libfirst.so
$ g++ ./first.cpp -lfirst -o hw-dinamic
$ ./hw-dinamic 
Здравствуй, Мир!
42</pre>
Приятной неожиданностью можно считать то, что сборка основной программы (из файла ‘first.cpp’) осталась практически без изменений по сравнению со случаем статической библиотеки (за исключением того, что исчезла необходимость в указании пути для поиска файла библиотеки с ключом <span class="inl-code">-L</span>: это и понятно, все библиотечный файлы находятся теперь в системных каталогах). Выполняя эту операцию, мы использовали четвёртое имя библиотеки (п. 4 списка выше).</p>

<p>Обращает на себя внимание необходимость наличия администраторских прав (вызов <span class="inl-code">sudo</span>) для установки библиотеки. Во время тестовых запусков программы можно обойтись без копирования в системный каталог <span class="inl-code">/usr/lib/</span>, если использовать переменную окружения <span class="inl-code">LD_LIBRARY_PATH</span>, которая содержит пути для поиска библиотек. В этом случае перед запуском программы её нужно модифицировать, а также снова (как в случае со статической библиотекой) указать ключ <span class="inl-code">-L</span>: 
<pre>$ g++ -fPIC -c ./second.cpp
$ ld -shared -soname libfirst.so.1 -o libfirst.so.1.0 ./second.o
$ ldconfig -n .
$ ln -s ./libfirst.so.1 ./libfirst.so
$ g++ ./first.cpp -L. -lfirst -o hw-dinamic
$ LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH ./hw-dinamic 
Здравствуй, Мир!
42</pre></p>

<p></p>

</body>
</html>
