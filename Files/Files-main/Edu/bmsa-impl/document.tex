\documentclass[14pt]{extarticle}
\usepackage{cmap}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{fullpage}
%\usepackage{graphicx}
\usepackage{indentfirst}

\usepackage{listings}
\lstset{language=[ISO]C++,basicstyle=\small,breaklines=true,showstringspaces=false}

\usepackage[unicode,draft=false,bookmarks=true,%citecolor=cyan,linkcolor=blue,
    bookmarksnumbered=true,bookmarksopen=false,pdfborder=0]{hyperref}%,colorlinks=true,backref=page,


%\usepackage{myheadings}
%\usepackage{fancyheadings}
%\pagestyle{fancy}
%colorlinks,urlcolor=black
% \hoffset=-0.5cm
% \voffset=-1.3cm
% \oddsidemargin=1.5cm %-9mm
%\topmargin=0cm
%\headsep=10pt
% \textheight=20cm
% \textwidth=15cm

\tolerance=1000

%\pagestyle{empty}

\usepackage[
a4paper, %mag=1000, includefoot,
left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm, headsep=1cm, footskip=1cm
]{geometry}

\usepackage{setspace}
\onehalfspacing

\parindent=1.25cm

%\usepackage{ucs}
\usepackage{graphicx}
\usepackage{rotating}
\usepackage{array}
%\usepackage[fixlanguage]{babelbib}
% \hypersetup{
% colorlinks=true,
% linkcolor=black,
% urlcolor=blue
% }

%\setcounter{tocdepth}{3}
%\graphicspath{{pic/}}

\newcommand{\nspace}{\hspace{0pt}}
\newcommand{\nbdash}{\nobreakdash-\nspace}

\title{Реализация $n$\nbdash{}мерного BMS\nbdash{}алгоритма
и методы обобщённого программирования}

\date{}

\author{А.М.~Пеленицын}

\begin {document} 
%\tableofcontents
\maketitle
\begin{abstract}
Описывается созданная программная реализация алгоритма
Берлекэмпа–Месси–Сакаты (BMS\nbdash{}алгоритма). Излагается ряд методов 
обобщённого программирования, основанных на использовании шаблонных механизмов
языка C++, как известных ранее, так и новых.
% Разработано и
% реализовано несколько вспомогательных алгоритмов, отсутствущих в работах по
% BMS\nbdash{}алгоритму.
\end{abstract}

\textbf{1. Введение.} Алгоритм Берлекэмпа–Месси (BM\nbdash{}алгоритм), созданный
в конце шестидесятых годов, нашёл многочисленные применения в различных областях
математики и информатики, обзор последних наиболее важных результатов содержится
в~\cite{Kurakin99}. В связи с декодированием алгебро-геометрических кодов
появилась необходимость обобщения BM\nbdash{}алгоритма на «многомерные
последовательности».

Впервые такое обобщение предложил С.~Саката~\cite{Sakata88}, \cite{Sakata90} и
его теперь принято называть алгоритмом Берлекэмпа—Месси—Сакаты
(BMS\nbdash{}алгоритмом). Приложения этого алгоритма к актуальным задачам
помехоустойчивого кодирования обсуждаются в~\cite{Sakata09a}. В~\cite{MayPel08}
представлена реализация кодека для одного класса алгебро-геометрических кодов с
использованием двумерного BMS-алгоритма.

В данной работе описывается реализация $n$\nbdash{}мерного BMS\nbdash{}алгоритма,
опирающаяся, в основном, на~\cite{CLO'S05} (также использовались идеи
работ~\cite{Sakata09} и~\cite{Sakata90}). Детально рассматривается ряд
известных, а также предлагаются новые шаблонные техники языка C++,
разрабатывающие методику обобщённого программирования~\cite[гл.~14]{VJ03},
\cite[п. 7.2]{Stroustrup07}.
% Описываются разработанные в
% рамках созданной реализации вспомогательные алгоритмы, отсутствущие в работах по
% BMS\nbdash{}алгоритму и не известные нам из доступной литературы.

\textbf{2. Инструменты реализации.} Реализация выполнена на языке
программирования C++~\cite{CppStd} с использованием стандартных расширений TR1~\cite{TR1}
(поддержка программирования с STL), библиотеки
NTL~\cite{NTL} (арифметика в конечных полях), части коллекции
библиотек Boost~\cite{Boost} (поддержка программирования с STL), библиотеки
Loki~\cite{loki} (поддержка обобщённого программирования). Для трансляции
использовался компилятор с языка C++ из свободной коллекции компиляторов GNU 
Compiler Collection (GCC) версии 4.4, в составе которого имеется, в частности, 
реализация TR1. Проект размещён в сети интернет на площадке Google
Code~\cite{cppmvpoly}: исходные коды доступны для просмотра онлайн, кроме того,
имеется доступ на чтение в Mercurial\nbdash{}репозиторий.

Результаты работы созданной реализации BMS\nbdash{}алгоритма проверялись с
помощью примеров, приведённых в статьях~\cite{Sakata88} и~\cite{Sakata90}. Кроме
того, для отдельных программных модулей был создан набор тестов, использующих
свободную легковесную систему автоматизированного модульного тестирования CUTE
(C++ Unit Testing Easier)~\cite{CUTE}. Последняя имеет ряд
преимуществ~\cite{Sommerlad} перед другими программными пакетами данного класса
(к примеру, CppUnit), а также предоставляет возможность тесной интеграции со
свободной средой разработки Eclipse~IDE~\cite{Eclipse}, использовавшейся в
разработке.

Основные программные сущности документированы в исходном коде в формате
Doxygen~\cite{Doxygen}, что позволяет извлекать документацию к проекту запуском
соответствующей утилиты (возможные выходные форматы: HTML, \LaTeX). 

Eclipse~IDE предоставляет средства интеграции почти всех перечисленных
инструментов: связь с Mercurial\nbdash{}репозиторием (посредством плагина
MercurialEclipse), развёрнутым на площадке Google Code, компиляция, линковка и
отладка средствами GCC (посредством плагина CDT), визуальное отображение
результатов тестов CUTE (посредством соответствующего плагина, предлагающегося
на сайте CUTE), генерация тегов при добавлении Doxygen-комментариев к модулям
программы.

\textbf{3. Архитектура реализации.} Была создана библиотека,
реализующая работу с полиномами многих переменных в объёме, необходимом для
выполнения BMS\nbdash{}алгоритма, а также сам алгоритм. Библиотека в
терминологии C++ является «headers-only», то есть вся реализация содержится в
заголовочных файлах C++, предназначенных для текстового включения в использующие 
её проекты и, таким образом, существует, прежде всего, в виде открытых исходных
кодов. Она включает в себя три основных шаблонных класса, 
\lstinline$Point<N>, Polynomial<T>, BMSAlgorithm< PolynomialT >$
и набор
вспомогательных шаблонных классов и свободных функций, занимающих в общей сложности 
около полутора тысяч строк кода (включая документацию внутри исходного кода). 
Наличие свободных функций является отступлением от чистого
объектно-ориентированного дизайна и следует рекомендациям~\cite[п. 44]{SA05},
касающимся использования языка программирования C++ как мультипарадигменного.
Также в соответствии с последним, в данной реализации особое внимание уделено
применению обобщённого программирования на основе шаблонов C++.
Объектно-ориентированный подход используется лишь в малой степени, как
дополнительное средство поддержки модульности; наследование применяется лишь 
в нескольких местах для удобства реализации идиом обобщённого 
программирования; не используется (динамический, основанный на виртуальных 
функциях) полиморфизм.

Шаблон класса \lstinline$Point<N>$ моделирует точку в $N$\nbdash{}мерной
целочисленной решётке. С точки зрения реализации он представляет собой
обёртку над шаблоном \lstinline$tr1::array<N, int>$ из библиотеки TR1, который,
в свою очередь, является статическим массивом с STL\nbdash{}совместимым
интерфейсом~\cite[п.~6.2]{TR1}. К отдельным координатам точки можно
обращаться с помощью операции взятия индекса (\lstinline$operator[]$). Важной частью интерфейса
\lstinline$Point<N>$ являются функции, реализующие различные упорядочения на
множестве точек решётки, такие как \lstinline$byCoordinateLess$ и
\lstinline$totalLess$. Первая (свободная функция) обеспечивает покоординатное
сравнение точек (частичное упорядочение), вторая (функция-член) задаёт
специальное мономиальное упорядочение~\cite[с.~7]{CLO'S05}, которое иногда
называют градуированным антилексикографическим упорядочением. Кроме того,
имеется набор свободных функций, реализующих поиск в наборе точек минимумов и
максимумов относительно разных порядков, поиск в наборе точек точки, меньшей
заданной, и~т.~п. Всё это необходимо выполнять на разных стадиях
BMS\nbdash{}алгоритма. 

Реализация \lstinline$totalLess$ в форме функции-члена (в отличие от других
функций, связанных с упорядочением) связана с желанием параметризовать
тип точки мономиальным упорядочением. Такая параметризация доступна с помощью
использования второго параметра шаблона \lstinline$Point<N>$, который имеет
значение по умолчанию, соответствующее градуированному антилексикографическому
упорядочению (по этой причине, а также для краткости, мы не указываем его в
тексте статьи). Этот приём будет отдельно описан в следующем
пункте.

Шаблон класса \lstinline$Polynomial<T>$ представляет тип полинома, причём типовый
параметр \lstinline$T$ обозначает тип коэффициентов соответствующего множества
полиномов. Технически \lstinline$Polynomial<T>$ является особого рода контейнером
для элементов типа \lstinline$T$. Полиномы многих переменных получаются
использованием того факта, что, к примеру, полином от двух переменных с
коэффициентами типа \lstinline$T$ неотличим по алгебраическим свойствам от
полинома от одной переменной с коэффициентами — полиномами от одной переменной и
коэффициентами типа \lstinline$T$ (см., например,~\cite[гл.~IV, \S~1,
п.~5]{Bourbaki65}); таким объектам соответствует тип
\lstinline$Polynomial<Polynomial<T>>$, который можно получить, используя
рассматриваемую библиотеку. 

Для удобства использования полиномов многих
переменных введён отдельный шаблон класса \lstinline$MVPolyType<n, T>$, где
первый параметр указывает на количество переменных в результирующем типе.
Например, следующие две строки кода определяют переменные одинакового типа,
представляющего полином от двух переменных с целочисленными коэффициентами.
\begin{lstlisting}
  Polynomial< Polynomial<int> > p;
  MVPolyType<2, int>::ResultT q;
\end{lstlisting}
Полиномы можно задавать в специальном строковом представлении, перечисляя
коэффициенты полинома в квадратных скобках через пробел в порядке возрастания
степеней. Например, \texttt{``[2 0 1]''} соответствует полиному $x^2 + 2$. Так
как полином от нескольких переменных это обычный полином с коэффициентами —
полиномами от переменных, число которых меньше на единицу, то строковое
представление таких полиномов будет содержать вложенные скобки. Например,
\texttt{``[[2 0 2] [1] [0 3]]''} соответствует полиному $3x^2y + 2y^2 + x + 2$ (с
точностью до возможного переименования переменных).

Для типов полиномов перегружены арифметические операции, которые необходимы для
реализации BMS-алгоритма. Это сложение полиномов, умножение полинома на скаляр и
умножение полинома на моном (\lstinline$operator<<$) — таким образом, из основных
операций с полиномами не реализовано лишь умножение. Поясним использование
операции умножения на моном. Считается, что моном задаётся своей степенью,
которая, в свою очередь, представлена типом \lstinline$Point<N>$. Вот пример
умножения полинома от двух переменных на моном $x^3y^2$:
\begin{lstlisting}
  MVPolyType<2, int>::ResultT p("[[1 2] [3]]");
  Point<2> mon; mon[0] = 3; mon[1] = 2;
  p <<= mon;
\end{lstlisting}
Стоит отметить, что так как шаблоны и перегрузка операций гарантируют контроль
типов времени компиляции, то замена в данном примере двоек в аргументах
шаблонов на два произвольных несовпадающих числа привела бы к ошибке компиляции.

Для полиномов многих переменных нельзя однозначно («наилучшим образом»)
определить степень. Для выполнения BMS-алгоритма требуется задавать некоторое
мономиальное упорядочение на множестве мономов, и определить
степень возможно. Однако работа со степенями полиномов, получаемых на каждой
итерации алгоритма, ведётся в значительной степени независимо от самих полиномов:
на каждой итерации сначала определяется геометрический образ очередного
приближения к решению, составленный из степеней будущих полиномов в
$N$\nbdash{}мерной решётке, а затем для каждой степени строится полином. Эти
факты привели к такому решению: в данной реализации тип полинома не хранит
никакой информации о своей степени (что бы ни подразумевалось под степенью полинома от
нескольких полиномов), если такая информация нужна клиенту типа, он должен
хранить и обновлять её самостоятельно.

Шаблон класса \lstinline$BMSAlgorithm<PolynomialT>$ параметризован типом
полиномов (в частности, алгоритм может работать с полиномами различного числа
переменных) и имеет довольно простой интерфейс, отражающий назначение и
использование BMS\nbdash{}алгоритма. Напомним, что BMS\nbdash{}алгоритм по
заданной конечной $n$\nbdash{}мерной последовательности строит конечное множество
полиномов от $n$ переменных, называемое минимальным множеством этой
последовательности. С технической точки зрения, $n$\nbdash{}мерная
последовательность ничем не отличается от полинома от $n$ переменных, потому тип
соответствующего аргумента алгоритма совпадает с типом полиномов, получаемых на
выходе алгоритма. Конструктор класса принимает последовательность и точку,
обозначающую конец последовательности, алгоритм обрабатывает все элементы в
диапазоне от элемента с мультииндексом $(0, \ldots, 0)$ до этого маркера конца
последовательности в порядке, заданном используемым мономиальным упорядочением
(напомним, что конкретное упорядочение является частью описания типа точки).
Метод данного шаблона класса \lstinline$computeMinimalSet$ возвращает коллекцию с
STL-совместимым интерфейсом, содержащую выход алгоритма. Тип этой коллекции
является частью определения шаблона класса, к нему можно обратиться следующим
образом:
\lstinline$BMSAlgorithm<PolynomialT>::PolynomialCollection$.

\textbf{4. Шаблонные техники.} Главным проектным решением библиотеки,
опирающимся на особенности шаблонов C++, является рекурсивное определение полиномов многих
переменных: \lstinline$Polynomial<...Polynomial<T>...>$, где глубина вложенности
равна $n$, моделирует тип полинома от $n$ переменных. Идея типа,
параметризованного самим собой, так называемое «рекурсивное инстанцирование»,
уже стало достаточно известным шаблоном проектирования (см., к примеру,
подробный, хотя и несколько более сложный, чем наш, пример, описывающий создание кортежей из значений произвольного набора
типов~\cite[гл.~21]{VJ03}). 

При появлении рекурсивной структуры возникает вопрос о способе её обхода. В
разных ситуациях это может потребовать более или мене сложных шаблонных техник.
Приведём некоторые из них. Заметим, что часть примеров
касается перегруженных операций для полиномов, и поскольку в
реализации использована «каноническая форма» арифметических операций, то вся 
реализация помещена в присваивающие версии операций, которые
реализованы как функции-члены шаблона класса
\lstinline$Polynomial<T>$~\cite[п.~27]{SA05}.

При использовании рекурсии в инстанцировании шаблонного типа обычно
предпринимаются попытки для облегчения её записи. В данном случае для этой цели
создан шаблон \lstinline$MVPolyType<n, T>$. Его определение достаточно
лаконично и даёт представление о типичном подходе к работе с
рекурсивно инстанцируемыми типами.
\begin{lstlisting}
template<int VarCnt, typename Coef>
struct MVPolyType {
    typedef Polynomial< // recursive "call" to MVPolyType
        typename MVPolyType<VarCnt - 1, Coef>::ResultT> ResultT;
};

template<typename Coef>
struct MVPolyType<1, Coef> {
    // multivariate polynomial from 1 variable
    // is just Polynomial
    typedef Polynomial<Coef> ResultT;
};
\end{lstlisting}
Как видно, рекурсия проводится по количеству переменных полинома, для полинома
одной переменной определена специализация шаблона, которая отвечает за остановку
рекурсии. Рекурсия по типу, таким образом, не сильно отличается от простейших
алгоритмов, использующих рекурсию по данным.

Аналогичным образом внутри типа полинома \lstinline$Polynomial<T>$ задаётся
константа \lstinline$VAR_CNT$, определяющая количество переменных полинома в
зависимости от типа \lstinline$T$, и синоним типа \lstinline$CoefT$ для
обозначения реального типа коэффициентов полинома. Например,
\lstinline$Polynomial<Polynomial<int>>::VAR_CNT$ равно $2$ и 
\lstinline$Polynomial<Polynomial<int>>::CoefT$ обозначает \lstinline$int$.

Изложенное выше связано с обходом и получением информации о самом типе,
имеющем рекурсивное определение. Далее рассматривается работа с объектами
такого типа.

Операция умножения полинома на скаляр не требует никаких дополнительных усилий
по сравнению со случаем полинома от одной переменной.
\begin{lstlisting}
Polynomial operator*=(CoefT const & c) {
    for (typename StorageT::iterator it = data.begin(); 
            it != data.end(); ++it) {
        (*it) *= c;
    }
    return *this;
}
\end{lstlisting}
Тип полинома является особого рода контейнером и реализован на базе одного из
стандартных контейнеров, который скрыт за синонимом типа \lstinline$StorageT$.
Соответствующее поле шаблона класса называется \lstinline$data$.

Под умножением на скаляр понимается вызов для полинома операции ‘*’ с объектом,
тип которого совпадает с \lstinline$CoefT$. Непосредственно умножение
производится вызовом той же операции для каждого элемента контейнера
\lstinline$data$. Если мы имеем дело с полиномом одной переменной, то
\lstinline$data$ должен содержать элементы типа \lstinline$CoefT$, для которого,
таким образом, должна быть определена операция ‘*’ (тип коэффициентов полинома
должен допускать умножение). В ином случае, снова будет вызвана приведённая выше
функция, однако изменится тип \lstinline$Polynomial$ — теперь это будет тип
полинома от переменных, число которых меньше на единицу. Ещё раз подчеркнём, что
описанная логика полностью реализована в приведённом выше коде, не требуется, к
примеру, использовать специализацию шаблонов, чтобы явно останавливать рекурсию.

Сложение двух полиномов так же, как умножение полинома на скаляр, не требует
дополнительных модификаций по сравнению с тем, что можно было бы закодировать,
не рассчитывая на использование в контексте рекурсивного определения. Можно сделать
вывод о том, что такого рода рекурсивный обход одного (умножение на скаляр) или
нескольких (сложение, сравнение двух полиномов на равенство) объектов одного
рекурсивно инстанцированного типа может быть доволен удобен. Однако при работе с
полиномами многих переменных возникает задача рекурсивного обхода объектов двух
разных типов одновременно (при этом глубина рекурсии разных типов должна быть
одинаковой). Примерами решения такой задачи в реализации данной библиотеки
являются операции умножения полинома на моном и обращения к коэффициенту полинома
от многих переменных по его мультииндексу (иначе: по мультистепени монома, при
котором стоит требуемый коэффициент). В обоих случаях требуется осуществлять
одновременный обход объекта типа \lstinline$Polynomial<...Polynomial<T>...>$ и
объекта типа \lstinline$Point<N>$, где число \lstinline$N$ совпадает с глубиной
вложенности типа полинома (а значит, в соответствии с нашими соглашениями~— с
числом переменных полинома).

Рассмотрим реализацию операции обращения к коэффициенту полинома по его
(мульти)индексу. В частном случае, при работе с полиномом от одной переменной,
обращаться к коэффициенту хотелось бы по обычному целочисленному индексу — по
этой причине реализована версия \lstinline$operator[](int)$. Для обращения к
коэффициенту полинома от многих переменных предоставляется перегруженная версия
\lstinline$operator[](Point<VAR_CNT>)$ (размерность точки должна
совпадать с количеством переменных полинома). Обсудим вопрос о том, как
должна продвигаться рекурсия. 

Пусть задана точка \lstinline$p$ типа \lstinline$Point<VAR_CNT>$.
Для полинома от многих переменных нужно обратиться к \lstinline$p[0]$\nbdash{}му 
элементу в контейнере \lstinline$data$ (это полином от переменных, количество
которых меньше на одну) и снова вызвать для него
\lstinline$operator[](Point<VAR_CNT>)$ с аргументом, представляющим как бы срез
точки \lstinline$p$: точку со всеми элементами \lstinline$p$, кроме
\lstinline$p[0]$\nbdash{}го. Для этой цели был создан шаблон класса
\lstinline$Slice<Dim, Offset>$, который хранит ссылку на исходную точку
размерности \lstinline$Dim$ и поддерживает операцию взятия индекса, причём при
обращении к \lstinline$i$\nbdash{}ому элементу по индексу возвращается
\lstinline$Offset+i$\nbdash{}ый элемент исходной точки. Используя этот шаблон в
реализации \lstinline$operator[](Point<VAR_CNT>)$ хотелось бы написать что-то
наподобие \lstinline$(data[p[0]])[make_slice(p)]$, где функция
\lstinline$make_slice$ создаёт срез, исключающий первый элемент точки. При этом в
интерфейс полинома нужно добавить \lstinline$operator[](Slice<Dim, Offset>)$, в
котором будет написано примерно то же, что и в исходной версии этой операции,
имеющей в качестве аргумента точку. К сожалению, точно так написать нельзя по
причине того, что в таком варианте не получается остановить рекурсию.

Для остановки рекурсии в шаблонных типах обычно используется специализация
шаблона (как в примере в \lstinline$MVPolyType$). В данном случае нужно было бы 
создать специализацию \lstinline$operator[](Slice<Dim, Dim-1>)$. Однако
существует ограничение языка C++~\cite[п. 12.3.3]{VJ03}, которое, в частности,
запрещает специализировать шаблонные члены шаблонов класса (именно таким является
\lstinline$operator[](Slice<Dim, Offset>)$). Так появляется ещё один уровень
косвенности, вместо \lstinline$(data[p[0]])[make_slice(p)]$ используется вызов
отельной свободной функции
\lstinline$apply_subscript(data[p[0]], make_slice(p))$, которая либо продвигает
рекурсию, вызывая \lstinline$operator[](Slice<Dim, Offset>)$ с переданным ей
срезом, либо (в своей специализации) останавливает рекурсию, вызывая 
\lstinline$operator[](int)$ с нулевым элементом полученного среза (этот элемент
стоит в последней координате исходной точки).

Удобно считать, что при обращении по индексу, выходящему за пределы
текущего контейнера, нужно вернуть «нулевое значение». Такое значение получается
с помощью шаблона \lstinline$CoefficientTraits$. Итоговый код, реализующий
операцию обращения по индексу выглядит так:
\begin{lstlisting}
template<typename T, typename S, typename Pt>
T applySubscript(S const & el, Pt const & pt) {
        return el[pt]; // call for operator[](Slice<...>)
}

template<typename T, typename S, int Dim>
T applySubscript(S const & el, Slice<Dim, Dim - 1> const & pt) {
        return el[pt[0]];  // call for operator[](int)
}

template<typename T>
typename Polynomial<T>::CoefT
Polynomial<T>::operator[](Point<VAR_CNT> const & pt) const {
    if (pt[0] < (int)0 || (int)data.size() <= pt[0])
        return CoefficientTraits<CoefT>::addId();
    else
        return applySubscript<Polynomial<T>::CoefT>(data[pt[0]], make_slice(pt));
}
\end{lstlisting}
Мы не приводим здесь код \lstinline$operator[](Slice<...>)$, так как он
полностью повторяет \lstinline$operator[](Point<VAR_CNT>)$, а
\lstinline$operator[](int)$ отличается только тем, что вместо вызова
\lstinline$apply_subscript$ стоит \lstinline$data[pt]$ (\lstinline$pt$ —
полученное целое число).

Остановимся теперь на использованных шаблонных техниках, не связанных напрямую с
идеей рекурсивной реализации полиномов от нескольких переменных. Упомянутый выше
шаблон \lstinline$CoefficientTraits$ представляет собой пример класса
характеристик или, в другом переводе, свойств 
(type traits)~\cite[гл.~15]{VJ03}, \cite[п.~2.10]{Alexandrescu02}. В данном
случае, этот класс предоставляет необходимую полиному информацию о типе коэффициентов,
а именно, значение этого типа, играющее роль аддитивно нейтрального элемента
(см. пример выше), мультипликативно нейтрального
\lstinline$CoefficientTraits<T>::multId()$, и функцию, возвращающую аддитивно
обратный элемент по заданному \lstinline$CoefficientTraits<T>::multId(T)$.
Применение характеристик основано на использовании специализаций шаблонов. Если
клиент шаблона класса полинома инстанцирует его с типом \lstinline$Bar$ для
коэффициентов, нулевое значение которого хранится в статической константе
\lstinline$Bar::ZERO$, то клиенту нужно предоставить специализацию
\lstinline$CoefficientTraits$, функция \lstinline$addId$ которого возвращает
\lstinline$Bar::ZERO$. Имеется общее определение
\lstinline$CoefficientTraits<T>$, которое будет использовано, 
если клиент не сделает последнего, оно реализует наиболее принятое поведение
(например, нулевое значение создаётся с помощью вызова конструктора без
аргументов типа \lstinline$T$).

При описании техники характеристик типов обычно упускают один важный вопрос, а
именно: как избежать дублирования в разных инстанциях шаблона характеристик.
Решение этой проблемы предложено в данной библиотеке и оно основывается на
использовании списков типов~\cite[гл. 3]{Alexandrescu02} и наследования. Сама
проблема в нашем случае возникает из-за того, что библиотека NTL, которая 
используется для арифметики в конечных полях, имеет четыре класса для полей
разного типа: простых и расширенных и характеристики два и характеристик,
отличных от двух. При этом все четыре класса имеют почти идентичный интерфейс,
потому при создании специализаций \lstinline$CoefficientTraits$ для них пришлось
бы четыре раза повторять один и тот же код. Этот код был выделен в
шаблон класса \lstinline$NtlCoefficientTraits<T>$, и
\lstinline$CoefficientTraits<T>$ наследуется от него, если \lstinline$T$
является одним из типом NTL или от «реализации по умолчанию»
\lstinline$DefaultCoefficientTraits<T>$ в противном случае. Проверка
принадлежности осуществляется метаоператором 
\lstinline$Select<bool flag, T, U>$ из библиотеки Loki, внутри которого
определён синоним типа \lstinline$Result$, совпадающий с типом \lstinline$T$,
если \lstinline$flag$ равен \lstinline$true$ и совпадающим с \lstinline$U$ в
противном случае. Таким образом, определение \lstinline$CoefficientTraits$
выглядит так:
\begin{lstlisting}
template<typename CoefT>
struct CoefficientTraits : public Loki::Select<
            isNtlType<CoefT>::result,
            NtlCoefficientTraits<CoefT>,
            DefaultCoefficientTraits<CoefT>   >::Result {};
\end{lstlisting}
\lstinline$isNtlType$ — небольшой шаблон класса, созданный на основе списков
типов (реализация которых также взята из Loki):
\begin{lstlisting}
template<typename T>
class isNtlType {
    typedef LOKI_TYPELIST_4(NTL::GF2, NTL::GF2E, 
                NTL::ZZ_p, NTL::ZZ_pE) NtlFiniteFieldTypes;

public:
    enum { result = Loki::TL::IndexOf<NtlFiniteFieldTypes, T>::value >= 0 };
};
\end{lstlisting}
Список типов (typelist) это тип, хранящий информацию о других типах и
позволяющий выполнять все те операции, которые характерны для списков. В
частности, с помощью шаблона \lstinline$IndexOf<TList, T>$ можно получить индекс
типа \lstinline$T$ в списке \lstinline$TList$ или $-1$, если \lstinline$T$ в нём
отсутствует.

Последняя шаблонная техника, которую мы обсудим, обеспечивает
параметризацию типа точки используемым в алгоритме мономиальным упорядочением,
она основана на классах стратегий (policy classes)~\cite[гл.~1]{Alexandrescu02}.
Стратегия — это связанный набор действий, связанных с разрабатываемым типом,
ортогональный к остальной функциональности этого типа, нуждающийся в
параметризации. Способ упорядочения точек $N$\nbdash{}мерной целочисленной
решётки — хороший претендент на вынесение его кода в стратегию. Общая идея
реализации состоит в том, чтобы добавить в разрабатываемый шаблонный тип ещё
один шаблонный параметр шаблона и наследоваться от него.
\begin{lstlisting}
template<
    typename T,
    template <typename> class Policy = DefaultPolicy>
class MyClass : public Policy<T> { /* ... */ };
\end{lstlisting}
В классической работе
\cite{Alexandrescu02} предлагается публичное наследование, при котором
составляющие базового класса попадают в интерфейс производного. В нашей
реализации клиенту не предоставляется непосредственный доступ к
функциям базового класса, вместо этого их вызов помещён в интерфейсные функции
производного класса (в данном случае, типа точки). Например, преобразование
данной точки в следующую за ней относительно мономиального упорядочения:
\begin{lstlisting}
template<int Dim, template <typename PointImpl> class OrderPolicy>
inline Point<Dim, OrderPolicy>&
Point<Dim, OrderPolicy>::operator++() {
    inc(data);
    return *this;
}
\end{lstlisting}
Функция \lstinline$inc()$ определена в шаблоне \lstinline$OrderPolicy$, от
которого наследуется \lstinline$Point$. Аналогично
\begin{lstlisting}
    bool operator<(Point<Dim> const & other) const {
        return totalLess(data, other.data);
    }
\end{lstlisting}
Функция \lstinline$totalLess()$ также определена в шаблоне
\lstinline$OrderPolicy$. Таким образом, шаблону \lstinline$OrderPolicy$ 
следует знать о типе поля \lstinline$data$ точки, последний используется
в качестве параметра шаблона \lstinline$OrderPolicy$.
\begin{lstlisting}
template<
    int Dim, // point dimension
    template <typename PointImpl> class OrderPolicy
        = GradedAntilexMonomialOrder>
class Point : OrderPolicy< std::tr1::array<int, Dim> > { /* ... */ };
\end{lstlisting}

%\textbf{Новые алгоритмы.} 
\begin{thebibliography}{99}
    \bibitem{Kurakin99} \emph{Куракин В.Л.} Алгоритм Берлекэмпа—Месси над
    коммутативными артиновыми кольцами главных идеалов // Фундаментальная и
    прикладная математика. 1999. Т.~5, вып.~4. C.~1061–1101.

    \bibitem{Sakata88} \emph{Sakata~S.} Finding a minimal set of linear recurring
    relations capable of generating a given finite two–dimensional array // J.
    Symb. Comp. 1988. Vol.~5. Pp.~321–337.

    \bibitem{Sakata90} \emph{Sakata S.} Extension of the Berlekamp—Massey
    algorithm to N dimensions // Inform. and Comput. 1990. Vol.~84. No.~2,
    P.~207–239.

    \bibitem{Sakata09a} \emph{Sakata~S.} The BMS algorithm and Decoding of AG
    Codes~// In Sala M. et al. (ed.), Gr\:obner bases, coding, and cryptography.
    Springer, 2009. P.~143–163.

    \bibitem{MayPel08} \emph{Маевский~А.Э., Пеленицын~А.М.} Реализация
    программного алгебро\nbdash{}геометрического кодека с
    применением алгоритма Сакаты~// Изв.~ЮФУ. Технические науки. 2008. №~8. С.~196–198.
    
    \bibitem{CLO'S05} \emph{Cox~D.A., Little~J.B., O'Shea~D.B.} Using Algebraic
    Geometry, Second Edition. Springer, 2005. 496 p.
    
    \bibitem{Sakata09} \emph{Sakata S.} The BMS algorithm // In Sala M.
    et al. (ed.), Gr\"obner bases, coding, and cryptography. Springer, 2009.
    P.~143–163.
    
    \bibitem{VJ03}\emph{Вандевурд~Д., Джосаттис~Н.} Шаблоны С++: справочник
    разработчика. М.:~Вильямс, 2003. 544~с.
    
    \bibitem{Stroustrup07}\emph{Stroustrup~B.} Evolving a language in and for
    the real world: C++ 1991–2006 // Procs. of the ACM HOPL-III. 2007.
    Pp.~4-1–4-59.
    
%     \bibitem{MayPel08} \emph{Алферов~А.П., Зубов~А.Ю., Кузьмин~А.С.,
%     Черёмушкин~А.В.} Основы криптографии, 3-е изд.  М:~Гелиос АРВ, 2005.
%     480~с.
    
    \bibitem{CppStd} \emph{International Standards Organization}: Programming
    Languages~– C++. International Standard ISO/IEC 14882:1998.

    \bibitem{TR1} \emph{International Standards Organization}: C++ Library
    Extensions. International Standard ISO/IEC TR 19768.
    URL: \url{http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf}
    (дата обращения: 03.08.2010).
    
    \bibitem{NTL} \emph{Shoup~V.} NTL: A Library for doing Number Theory~//
    URL: \url{http://shoup.net/ntl/} (дата обращения: 03.08.2010).
    
    \bibitem{Boost} Boost C++ Libraries. URL: \url{http://www.boost.org/} (дата
    обращения 03.08.2010).
    
    \bibitem{loki} Loki C++ library~// URL:
    \url{http://loki-lib.sourceforge.net/} (дата обращения: 25.08.2010). 
    
    \bibitem{cppmvpoly} \emph{Pelenitsyn~A.} Multivariate polynomials for C++~//
    URL: \url{http://code.google.com/p/cpp-mv-poly/} (дата обращения: 03.08.2010).
    
    \bibitem{CUTE} CUTE: C++ Unit Testing Easier~// URL:
    \url{http://r2.ifs.hsr.ch/cute} (дата обращения: 03.08.2010).
    
    \bibitem{Sommerlad} \emph{Sommerlad~P.} C++ Unit Testing Easier: CUTE // URL:
    \url{http://wiki.hsr.ch/PeterSommerlad/wiki.cgi?CuTe} (дата обращения:
    03.08.2010).
    
    \bibitem{Eclipse} Официальный сайт Eclipse IDE~// URL:
    \url{http://www.eclipse.org/} (дата обращения: 03.08.2010).
    
    \bibitem{Doxygen} Официальный сайт Doxygen~// URL:
    \url{http://www.stack.nl/~dimitri/doxygen/}
    (дата обращения: 03.08.2010).
    
    \bibitem{SA05}\emph{Саттер~Г., Александреску~А.} Стандарты программирования
    на С++. М.:~Вильямс, 2005. 224~с.
    
    \bibitem{Bourbaki65}\emph{Бурбаки~Н.} Алгебра (Многочлены и поля.
    Упорядоченные группы). М.:~Наука, 1965. 300~с.
    
    \bibitem{Alexandrescu02}\emph{Александреску~А.} Современное проектирование
    на C++. М.: Вильямс, 2002. 336~с.
    
%     \bibitem{GoF}Гамма~Э., Хелм~Р., Джонсон~Р., Влиссидес~Дж. Приёмы
%     объектно\nbdash{}ориентированного проектирования. Паттерны проектирования.
%     СПб.: Питер, 2006. 366 с.
\end{thebibliography}

\end {document}
