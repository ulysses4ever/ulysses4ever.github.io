Гончаров 4

l,r : TreeNode<T>;
Это плохие имена для полей классов. Никогда в промышленном коде вы не увидите таких имен. left, right.

В первом списке отрицательныъ элементов больше чем во втором
опечатка.

В AmountOfNegative if'ы с повторяющимися кусками условий. Я бы сделал без повторов, но с вложенными:
if p1 <> nil then
begin
  p1n := p1.next
  if p1.data < 0 then
    n1 += 1;
end;

4: это совсем не похоже на условие идеальной сбалансированности.
========================================

Белоусько 4

IsItLeaf лучше назвать IsLeaf.

    Result := InfixLeavesString(root.l) + ' ' + root.data.tostring + InfixLeavesString(root.r)
 очень длинная строка, нужно разбить на две, вставив переход на новую строку перед одним из +.

Насчёт IsFirstLonger: я зря претензии выдвигал, там условные операторы прилично написаны.

4
  else if (root.l = nil) or (root.r = nil) then
    exit
это неправильно если хотя бы один потомок не пуст, значения в нём должны быть больше или меньше корня, а вы не проверяете это и сразу выходите. И в целом решение неверное: недостаточно сравнивать значение в корне только со значениями в двух потомках, ведь условие в опредлении BST накладывается на все элементы поддерева (левого и правого). Нужно, спускаясь, по дереву проверять, что элемент в очередном узле удовлетворяет полагающимся ограничениям.
========================================

Валяев 4

1: стоило написать в комментарии, как поведёт себя функция, если нет чётных.
  var i := 0;
  Result := FirstEvenElemRecur(i);
А
Result := FirstEvenElemRecur(0);
никак?

2:
  if root = nil then exit;
Не хватает перехода на новую строку.
Нет проверки на то, что символ цифровой.

3:
Требовалось решение за один проход по обоим спискам одновременно.

4:
abs(CountOfTops(root.left) - CountOfTops(root.right)) in [0..1]
лучше
abs(CountOfTops(root.left) - CountOfTops(root.right)) < 2
что такое Tops? Nodes!

  else if abs(CountOfTops(root.left) - CountOfTops(root.right)) in [0..1] then
    Result := IsPerfectlyBalanced(root.left) and IsPerfectlyBalanced(root.right)
  else
    Result := false;
а сразу:
Result := (abs(CountOfTops(root.left) - CountOfTops(root.right)) < 2)
    and IsPerfectlyBalanced(root.left) and IsPerfectlyBalanced(root.right)
?

Алгоритм, конечно, не очень хороший: вы много раз будете пересчитывать одно и то же (количство потомков у узлов на нижних уровнях: сначала при подсчёте потомков узлов на верхних, а потом снова, когда дойдёте до самих этих нижних). Лучше рекурсивно спускаться до самого низа и начинать считать оттуда, передавая результат подсчёта сверху-вниз в var-раметрах рекурсивных вызовов.
========================================

Есипов 2

> //к сожелению ничего не получилось, если можно, напишите в коментариях к кр кратко как это делать.

Да кратко сложно написать. Попросите у друзей один вариант, посмотрите и попробуйте второй пропрешать. Если что, приходите как-нибудь между/после занятий, могу пообъяснять.
========================================

Платонов 3

1:
result := 666; //Думаю понятно что это ознчает? (Не найден)
Нет, непонятно. Значение должно быть одно из: 0, 1, MaxInt, но никак не 666. В любом случае, об этом должно быть написано в комментарии перед подпрограммой. 

if i = a.Length then exit;
Не хватает перехода на новую строку.

Ввод масива с клавиатуры это плохо, надо Arrays.CreateRandomIntegerArray.

2:
Сформировать строку, 
содержащую все символы из листов дерева в порядке инфиксного обхода.
//Создаёт строку содержащую значения корней и листьев при инфиксном обходе
Найдите 10 отличий, как говорится. Не зачитывается.

3:
хотелось бы решения за один проход по обоим спискам одновременно.
Мы никогда не печатаем на консоль в подпрограммах, если об этом явно не написано — ошибка!

4: 
Зачем переводить целые в строку? Не будет работать правильно для чисел, не являющихся однозначными. БДП 2 - 13 перейдёт в строку 213 и сравнение первого и второго символа не пройдёт. Ну и вообще, алгоритм
========================================

Казарян 2
+/- +/- +/- -

procedure CreateRandomTree
function CreateRandomTree
Это абсолютный кошмар. Что мешает оставить одну функцию?

/// Класс бинарного дерева
TreeNode<T> = class
Это неправильный комментарий. Это класс _узла_ бинарного дерева.

1:
Result := 0
я бы возвращал что-то нечётное. Например, 1 или -1. И написал бы об этом в комментарии перед подпрограммой.

Odd(n) -> Odd(a[n])

2:
('0' < root.data) and (root.data < '9')
почему строгие неравенства? Есть char.IsDigit.

3:
Требовалось решение за один проход по обоим спискам одновременно.

За каждое из трёх решенных могу зачесть только по половинке. В сумме набирается меньше половины, к сожалению.
========================================

Папиж 3
+/- +/- +/- -

///опишем дерево как класс
Лучше писать так:
/// класс для представления узла бинарного дерева

1:
function ArrOReal
Тратить на такое время контрольной совершенно неправильно. Такие функции надо или иметь под рукой или исопльзовать стандартный модуль Arrays. На худой конец создать руками в основной программе массив:
var arr : array of real := (1.0, 2.0, 3.0);
это намного лучше, чем пустая трата времени.

PrintArr то же самое: Arrays.WritelnArray.

function FirstMinus(a: array of real; i: integer): real;
Целый параметр не должен быть виден пользователю подпрограммы. Для этого мы использовали вложенные подпрограммы.

  if i = a.Length - 1 then
    exit;
А почему вы отказываетесь проверять элемент a[a.Length - 1]? Он ничем не хуже других.

FirstMinus —> FirstNegative.

2:
В задании сказано: Дано бинарное дерево символов. У вас дерево целых.

3:
Неплохо было бы в комментариях к подпрограмме CompareNodes написать, в каком случае, что она возвращает.

4:
if (t.left = nil) or (t.right = nil) then exit;
это неправильно: если одно из поддеревьев пусто, это не значит, что дерево не может быть БДП.
========================================

Григоренко 2

Когда вы пишите вызов функции (например, FindFirstOddElement(a,i+1); в первом задании или StringWithAllChars(root.r); во втором), то результат надо чему-то присваивать.
========================================

Ботова 2

1: циклы использовать нельзя, рекурсия полностью их заменяет.

4: условие сбалансированности деерва несоклько сложней. У вас, если не выполнено
(r.right<>nil) and (r.left<>nil)
то результат false, а в ид. сбалансированных БД бывают элементы с одним дочерним элементом. Определение: общее количество потомков в левом и правом поддеревьях отличается не более чем на 1. Может быть корень и один левый дочерний и всё — это идеально сбалансированное дерево, но ваша программа его не примет.

